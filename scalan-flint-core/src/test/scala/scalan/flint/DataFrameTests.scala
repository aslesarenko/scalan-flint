package scalan.primitives

import java.lang.reflect.Method

import scala.language.reflectiveCalls
import scalan._
import scalan.common.{SegmentsDsl, SegmentsDslExp, Lazy}
import scalan.compilation.{StructsCompiler, DummyCompiler, DummyCompilerWithPasses}
import scalan.flint.{DataFramesDslExp, DataFramesDsl}

class DataFrameTests extends BaseViewTests {
  trait MyProg extends Scalan with DataFramesDsl {
    lazy val t1 = fun { (in: DF[(Int,Int)]) =>
      in.filter(fun { p => p._1 > 10 })
    }

    lazy val t2 = fun { (in: Rep[(DataFrame[(Int,Int)], DataFrame[(Int,Double)])]) =>
      val Pair(t1, t2) = in
      t1.filter(fun { p => p._1 > 10 })
        .join(t2, fun((r1: Rep[(Int,Int)]) => r1._1), fun((r2: Rep[(Int,Double)]) => r2._1), 1000, 0)
    }

    object Q1 {
      // The types can be replaced by Any in autogenerated code (used there for clarity)
      trait LineItem extends Struct {}
      implicit val eLineItem: Elem[LineItem] = structElement(Seq(
        "l_orderkey" -> IntElement,
        "l_partkey" -> IntElement,
        "l_suppkey" -> IntElement,
        "l_linenumber" -> IntElement,
        "l_quantity" -> DoubleElement,
        "l_extendedprice" -> DoubleElement,
        "l_discount" -> DoubleElement,
        "l_tax" -> DoubleElement,
        "l_returnflag" -> CharElement,
        "l_linestatus" -> CharElement,
        "l_shipdate" -> LongElement, //TODO DateElement
        "l_commitdate" -> LongElement,
        "l_receiptdate" -> LongElement,
        "l_shipinstruct" -> StringElement,
        "l_shipmode" -> StringElement,
        "l_comment" -> StringElement
      )).asElem[LineItem]

      trait Projection extends Struct {}
      implicit val eProjection: Elem[Projection] = structElement(Seq(
        "sum_qty" -> DoubleElement,
        "sum_base_price" -> DoubleElement,
        "sum_disc_price" -> DoubleElement,
        "sum_charge" -> DoubleElement,
        "avg_qty" -> DoubleElement,
        "avg_price" -> DoubleElement,
        "avg_disc" -> DoubleElement,
        "count_order" -> IntElement, //TODO size_t
        "l_returnflag" -> CharElement,
        "l_linestatus" -> CharElement
      )).asElem[Projection]

      trait GroupBy extends Struct {}
      implicit val eGroupBy: Elem[GroupBy] = structElement(Seq(
        "l_returnflag" -> CharElement,
        "l_linestatus" -> CharElement
      )).asElem[GroupBy]

      trait Aggregate extends Struct {}
      implicit val eAggregate: Elem[Aggregate] = structElement(Seq(
        "sum_qty" -> DoubleElement,
        "sum_base_price" -> DoubleElement,
        "sum_disc_price" -> DoubleElement,
        "sum_charge" -> DoubleElement,
        "sum_disc" -> DoubleElement,
        "count_order" -> IntElement  //TODO element for size_t
      )).asElem[Aggregate]

      val predicate = fun({ (li: Rep[LineItem]) =>
        li.getLong("l_shipdate") <= 19981201L
      })(Lazy(eLineItem), element[Boolean])

      val map = fun({ (li: Rep[LineItem]) =>
        val key = struct(
          "l_returnflag"->li("l_returnflag"),
          "l_linestatus"->li("l_linestatus")
          )
        val value = struct(
          "sum_qty"->li("l_quantity"),
          "sum_base_price"->li.getDouble("l_extendedprice"),
          "sum_disc_price"->li.getDouble("l_extendedprice")*(toRep(1d) - li.getDouble("l_discount")),
          "sum_charge" -> li.getDouble("l_extendedprice") *
                          (toRep(1d) - li.getDouble("l_discount")) * (toRep(1d) + li.getDouble("l_tax")),
          "sum_disc" -> li("l_discount"),
          "count_order" -> toRep(1)
          )
        Pair(key.asRep[GroupBy], value.asRep[Aggregate])
      })(Lazy(eLineItem), element[(GroupBy, Aggregate)])

      val reduce = fun({ (in: Rep[(Aggregate, Aggregate)]) =>
        val Pair(dst,src) = in
        struct(
          "sum_qty" -> (dst.getDouble("sum_qty") + src.getDouble("sum_qty")).asRep[Any],
          "sum_base_price" -> (dst.getDouble("sum_base_price") + src.getDouble("sum_base_price")).asRep[Any],
          "sum_disc_price" -> (dst.getDouble("sum_disc_price") + src.getDouble("sum_disc_price")).asRep[Any],
          "sum_charge" -> (dst.getDouble("sum_charge") + src.getDouble("sum_charge")).asRep[Any],
          "sum_disc" -> (dst.getDouble("sum_disc")  + src.getDouble("sum_disc")).asRep[Any],
          "count_order" -> (dst.getDouble("count_order") + src.getDouble("count_order")).asRep[Any]
          ).asRep[Aggregate]
      })(Lazy(element[(Aggregate, Aggregate)]), element[Aggregate])

      val projection = fun({ (in: Rep[(GroupBy,Aggregate)]) =>
        val Pair(key, value) = in
        struct(
          "l_returnflag" ->  key("l_returnflag"),
          "l_linestatus" -> key("l_linestatus"),
          "sum_qty" ->  value("sum_qty"),
          "sum_base_price" -> value("sum_base_price"),
          "sum_disc_price" ->  value("sum_disc_price"),
          "sum_charge" ->  value("sum_charge"),
          "avg_qty" -> value.getDouble("sum_qty") / value.getDouble("count_order"),
          "avg_price" -> value.getDouble("sum_base_price") / value.getDouble("count_order"),
          "avg_disc" -> value.getDouble("sum_disc") / value.getDouble("count_order"),
          "count_order" ->  value("count_order")
        ).asRep[Projection]
      })(Lazy(element[(GroupBy, Aggregate)]), eProjection)

      val compare = fun({ (in: Rep[(Projection,Projection)]) =>
        val Pair(a,b) = in
        val diff = a.getChar("l_returnflag") - b.getChar("l_returnflag")
        val res = IF (diff !== toRep('0')) { diff } ELSE { a.getChar("l_linestatus") - b.getChar("l_linestatus") }
        res.toInt
      })(Lazy(element[(Projection,Projection)]), IntElement)

      lazy val query = fun { (lineitem: DF[LineItem]) =>
        lineitem
          .filter(predicate)
          .mapReduce[GroupBy,Aggregate](map, reduce, 10000)
          .project(projection)
          .sort(compare, 100);
      }
    }

    lazy val arrT1 = fun { (in: Rep[Array[(Int,Int)]]) =>
      val arrayDf = ArrayDF(in)
      arrayDf.filter(fun { p => p._1 > 10 })
    }
    lazy val arrT2 = fun { (in: Rep[(Array[(Int,Int)], Array[(Int,Double)])]) =>
      val Pair(in1, in2) = in
      val t1 = ArrayDF(in1)
      val t2 = ArrayDF(in2)
      t1.filter(fun { p => p._1 > 10 })
        .join(t2, fun((r1: Rep[(Int,Int)]) => r1._1), fun((r2: Rep[(Int,Double)]) => r2._1), 1000, 0)
    }
    lazy val arrT3 = fun { (in: Rep[(Array[(Int,Int)], Array[(Int,Double)])]) =>
      val Pair(in1, in2) = in
      val t1 = ArrayDF(in1)
      val t2 = ArrayDF(in2)
      type JoinedRec = ((Int, Int), (Int, Double))
      val cmp = fun({ (in: Rep[(JoinedRec, JoinedRec)]) =>
        val Pair(Pair(Pair(in00, in01), Pair(in02, in03)), Pair(Pair(in10, in11), Pair(in12, in13))) = in
        in00 - in10
      })

      t1.filter(fun { p => p._1 > 10 })
        .join(t2, fun((r1: Rep[(Int,Int)]) => r1._1), fun((r2: Rep[(Int,Double)]) => r2._1), 1000, 0)
        .sort(cmp, 1000)
    }
  }

  class Ctx extends TestCompilerContext {

    class ScalanCake extends ScalanDslExp with MyProg with DataFramesDslExp {
      override val cacheElems = false
      //      override val cacheIsos = false
      //      override val cachePairs = false

    }
    override val compiler = new DummyCompilerWithPasses(new ScalanCake)
      with StructsCompiler[ScalanDslExp with MyProg]

    import compiler.scalan._

    def testCompare[T](name: String)(implicit eT: Elem[T]) = {
      val fields = eT match { case se: StructElem[_] => se.fields.map(f => (f._1, true)).toList case _ => Nil}
      testCompareFields[T](name, fields)
    }

    def testCompareFields[T](name: String, fields: List[(String, Boolean)])(implicit eT: Elem[T]) = {
      val f = compareFun[T](fields)
      emit(name, f)
    }
  }

  test("t1") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.emit("t1", t1)
  }
  test("t2") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.emit("t2", t2)
  }

  test("arrT1") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.test("arrT1", arrT1)
  }
  test("arrT2") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.test("arrT2", arrT2)
  }
  test("arrT3") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.test("arrT3", arrT3)
  }

  test("compare") {
    val ctx = new Ctx
    import ctx.compiler.scalan._
    ctx.testCompare[Int]("Int")
    ctx.testCompare[String]("String")
    ctx.testCompare("struct1")(tupleStructElement(element[Int]))
    ctx.testCompare("struct2")(tupleStructElement(element[Int], element[String]))
    ctx.testCompare("struct3")(tupleStructElement(element[Int], element[String], element[Double]))
    ctx.testCompareFields("struct4", List(("_1", false), ("_3", true)))(tupleStructElement(element[Int], element[String], element[Double]))
  }
//  test("Q1") {
//    val ctx = new Ctx
//    import ctx.compiler.scalan._
//    ctx.emit("Q1", Q1.query)
//  }

}

