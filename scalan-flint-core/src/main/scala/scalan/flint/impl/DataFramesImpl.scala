package scalan.flint

import scalan._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends Scalan with DataFrames {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[T](p: Rep[DataFrame[T]]): DataFrame[T] = {
    proxyOps[DataFrame[T]](p)(scala.reflect.classTag[DataFrame[T]])
  }

  // familyElem
  class DataFrameElem[T, To <: DataFrame[T]](implicit _eT: Elem[T])
    extends EntityElem[To] {
    def eT = _eT
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[DataFrame[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[T]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[T]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[T]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[T](implicit eT: Elem[T]): Elem[DataFrame[T]] =
    cachedElem[DataFrameElem[T, DataFrame[T]]](eT)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanionAbs(p: Rep[DataFrameCompanionAbs]): DataFrameCompanionAbs =
    proxyOps[DataFrameCompanionAbs](p)

  abstract class AbsFlintFileDF[T]
      (fileName: Rep[String])(implicit eT: Elem[T])
    extends FlintFileDF[T](fileName) with Def[FlintFileDF[T]] {
    lazy val selfType = element[FlintFileDF[T]]
  }
  // elem for concrete class
  class FlintFileDFElem[T](val iso: Iso[FlintFileDFData[T], FlintFileDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, FlintFileDF[T]]
    with ConcreteElem[FlintFileDFData[T], FlintFileDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDF[T]]
    }
  }

  // state representation type
  type FlintFileDFData[T] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[T](implicit eT: Elem[T])
    extends EntityIso[FlintFileDFData[T], FlintFileDF[T]] with Def[FlintFileDFIso[T]] {
    override def from(p: Rep[FlintFileDF[T]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new FlintFileDFElem[T](self)
    lazy val selfType = new FlintFileDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class FlintFileDFIsoElem[T](eT: Elem[T]) extends Elem[FlintFileDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new FlintFileDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    def apply[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
      mkFlintFileDF(fileName)
  }
  object FlintFileDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDF: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[T](p: Rep[FlintFileDF[T]]): FlintFileDF[T] =
    proxyOps[FlintFileDF[T]](p)

  implicit class ExtendedFlintFileDF[T](p: Rep[FlintFileDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlintFileDFData[T]] = isoFlintFileDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[T](implicit eT: Elem[T]): Iso[FlintFileDFData[T], FlintFileDF[T]] =
    reifyObject(new FlintFileDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]]
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsInputDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends InputDF[T](dataSourceId) with Def[InputDF[T]] {
    lazy val selfType = element[InputDF[T]]
  }
  // elem for concrete class
  class InputDFElem[T](val iso: Iso[InputDFData[T], InputDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, InputDF[T]]
    with ConcreteElem[InputDFData[T], InputDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDF[T]]
    }
  }

  // state representation type
  type InputDFData[T] = String

  // 3) Iso for concrete class
  class InputDFIso[T](implicit eT: Elem[T])
    extends EntityIso[InputDFData[T], InputDF[T]] with Def[InputDFIso[T]] {
    override def from(p: Rep[InputDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new InputDFElem[T](self)
    lazy val selfType = new InputDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class InputDFIsoElem[T](eT: Elem[T]) extends Elem[InputDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new InputDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
      mkInputDF(dataSourceId)
  }
  object InputDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkInputDF(p)
  }
  lazy val InputDF: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[T](p: Rep[InputDF[T]]): InputDF[T] =
    proxyOps[InputDF[T]](p)

  implicit class ExtendedInputDF[T](p: Rep[InputDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[InputDFData[T]] = isoInputDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[T](implicit eT: Elem[T]): Iso[InputDFData[T], InputDF[T]] =
    reifyObject(new InputDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkInputDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]]
  def unmkInputDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsPhysicalRddDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends PhysicalRddDF[T](dataSourceId) with Def[PhysicalRddDF[T]] {
    lazy val selfType = element[PhysicalRddDF[T]]
  }
  // elem for concrete class
  class PhysicalRddDFElem[T](val iso: Iso[PhysicalRddDFData[T], PhysicalRddDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, PhysicalRddDF[T]]
    with ConcreteElem[PhysicalRddDFData[T], PhysicalRddDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PhysicalRddDF: missing fields List(dataSourceId)")
    override def getDefaultRep = PhysicalRddDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDF[T]]
    }
  }

  // state representation type
  type PhysicalRddDFData[T] = String

  // 3) Iso for concrete class
  class PhysicalRddDFIso[T](implicit eT: Elem[T])
    extends EntityIso[PhysicalRddDFData[T], PhysicalRddDF[T]] with Def[PhysicalRddDFIso[T]] {
    override def from(p: Rep[PhysicalRddDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      PhysicalRddDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new PhysicalRddDFElem[T](self)
    lazy val selfType = new PhysicalRddDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class PhysicalRddDFIsoElem[T](eT: Elem[T]) extends Elem[PhysicalRddDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PhysicalRddDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class PhysicalRddDFCompanionAbs extends CompanionDef[PhysicalRddDFCompanionAbs] with PhysicalRddDFCompanion {
    def selfType = PhysicalRddDFCompanionElem
    override def toString = "PhysicalRddDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
      mkPhysicalRddDF(dataSourceId)
  }
  object PhysicalRddDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkPhysicalRddDF(p)
  }
  lazy val PhysicalRddDF: Rep[PhysicalRddDFCompanionAbs] = new PhysicalRddDFCompanionAbs
  implicit def proxyPhysicalRddDFCompanion(p: Rep[PhysicalRddDFCompanionAbs]): PhysicalRddDFCompanionAbs = {
    proxyOps[PhysicalRddDFCompanionAbs](p)
  }

  implicit case object PhysicalRddDFCompanionElem extends CompanionElem[PhysicalRddDFCompanionAbs] {
    lazy val tag = weakTypeTag[PhysicalRddDFCompanionAbs]
    protected def getDefaultRep = PhysicalRddDF
  }

  implicit def proxyPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]]): PhysicalRddDF[T] =
    proxyOps[PhysicalRddDF[T]](p)

  implicit class ExtendedPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[PhysicalRddDFData[T]] = isoPhysicalRddDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPhysicalRddDF[T](implicit eT: Elem[T]): Iso[PhysicalRddDFData[T], PhysicalRddDF[T]] =
    reifyObject(new PhysicalRddDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkPhysicalRddDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]]
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  registerModule(DataFrames_Module)
}

// Seq -----------------------------------
trait DataFramesSeq extends ScalanSeq with DataFramesDsl {
  self: DataFramesDslSeq =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class SeqFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName) {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new SeqFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: FlintFileDF[T] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class SeqInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId) {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new SeqInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: InputDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId) {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new SeqPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: PhysicalRddDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends ScalanExp with DataFramesDsl {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new ExpFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[T] @unchecked =>
      Some((p.asRep[FlintFileDF[T]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new ExpInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[T] @unchecked =>
      Some((p.asRep[InputDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId)

  object PhysicalRddDFMethods {
  }

  object PhysicalRddDFCompanionMethods {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new ExpPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PhysicalRddDFElem[T] @unchecked =>
      Some((p.asRep[PhysicalRddDF[T]].dataSourceId))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAO1XTWwbRRSeteP4L6QhlAoqVaTG/IPdIqEecqiCY6Mgk1jZgJCpQOPdsTNldnazM45sDj32ADfEDSFRiQtSL4gTQqqQEBLiwAmhSpw5laKqB3oC8Wa8u147dhNXIid8GO3Ovnk/3/e9mfH12yglfPS0sDDDvOQQiUumfl4TsmhWuaSy/4ZrdxlZJ+3H3O8+P//l6W8S6EQTze9isS5YE2UHD9WeFz2bZK+OsphbREjXFxKdresIZctljFiSurxMHacrcYuRcp0KuVpHcy3X7u+hK8iooyXL5ZZPJDErDAtBRDCfISojGr1n9Xt/yxvG4GVVRTlWxY6PqYT0IcbSwH6beGafu7zvSLQYpLblqbTAJk0dz/VlGCIN7nZdO3yd4xgm0HL9Mt7HZQjRKZvSp7wDK/Mett7HHbIJJsp8DhIWhLV3+p5+T9ZRTpA9AGjD8Zie6XkIIWDgZZ1EaYhPKcKnpPApmsSnmNEPsPrY8N1eHw1+RhKhngcuXjzEReiBVLld/PCS9c49M+8k1OKeSiWtK5wHR09MUYOmAnD8cftjcfe1axcSKNdEOSrWWkL62JJxygO08phzV+qcIwCx3wG2CtPY0lHWwGZMElnLdTzMwVMA5QLwxKhFpTJWcwsBO1OgT0uPhKZGzzOielem1Kt1U8GMNW49/tJTf1TfTqDEaIgsuDRB+H7oVKLsOpa45oNN4F+NJyQydjTIasj2wsnFGqNcHmXFcEzfJ+MIu2du/Wn/cA5dSkSIBwkejWRwkRI3f83/8tzFBMo0dUvUGO40AXRRZcTZ8isul02UcfeJP/iS3sdMPU0kPW2TNu4yGVARxzAJGEq0MrV5PaIAXtWNYoQA5Ada33Q5KdYaxb/Mnz65rqTso4XBl0E3/0Mv/P3bYltqlUuUaVOmmzOEOAkbQYTIk9Nk4JGGTx3YdvbJK99/++adG5sprYTloKi3MOuSwSYQ1DSsT4VNFAoSzQ8NxtnMDVI2XYc8XLhL3732kdS8Gb3RfWardRkae1WvO3sfCsP97qurVx+988V7j+g+zbSodLBXPDdDl4ZN9R92IRrV/GIl2Pe1DM+PfszrbqkBh+u1Ka2hxtPRNz0UgIGTsZWVeAGF2LJYsDNGqDVtBBSSnTCLOaX/Qzv1YLaFSGhnpgsNkDm1XT/Jbl+8kUCp11GqDR0l6ijVcrvcDiGHw1GSnnw1nDNGIQeIMWwnEcT6t4KG9U7ajfLGaE3HsI8dQB2Nob5gg0fT7foW2bAP9qwanp3s9gU9lmZRV3qDe105q7KWglXHpap4loWYfeV/lo/E8kON3b6g0HPbtj0r16dG1h4X4wczno33GIfzE/FKwlHxAKo4FLYRisamJ6C7HAWdgOzIxepBMVDjp0ObwDA3LFYGtwdeaiulBwX4EGzyhm0GRxsAeOXeZ5vP//z17/pikFOHJFxNePQnIn4hGBPkMDz8L4jlDApRR6fO91+o3K8Jpw0AAA=="
}
}

