package scalan.flint

import scalan._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends DataFrames with Scalan {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[T](p: Rep[DataFrame[T]]): DataFrame[T] = {
    proxyOps[DataFrame[T]](p)(scala.reflect.classTag[DataFrame[T]])
  }

  // familyElem
  class DataFrameElem[T, To <: DataFrame[T]](implicit _eT: Elem[T])
    extends EntityElem[To] {
    def eT = _eT
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[DataFrame[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[T]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[T]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[T]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e")
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[T](implicit eT: Elem[T]): Elem[DataFrame[T]] =
    cachedElem[DataFrameElem[T, DataFrame[T]]](eT)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanion(p: Rep[DataFrameCompanion]): DataFrameCompanion =
    proxyOps[DataFrameCompanion](p)

  abstract class AbsFlintFileDF[T]
      (fileName: Rep[String])(implicit eT: Elem[T])
    extends FlintFileDF[T](fileName) with Def[FlintFileDF[T]] {
    lazy val selfType = element[FlintFileDF[T]]
  }
  // elem for concrete class
  class FlintFileDFElem[T](val iso: Iso[FlintFileDFData[T], FlintFileDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, FlintFileDF[T]]
    with ConcreteElem[FlintFileDFData[T], FlintFileDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDF[T]]
    }
  }

  // state representation type
  type FlintFileDFData[T] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[T](implicit eT: Elem[T])
    extends Iso[FlintFileDFData[T], FlintFileDF[T]] {
    override def from(p: Rep[FlintFileDF[T]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eTo = new FlintFileDFElem[T](this)
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    def apply[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
      mkFlintFileDF(fileName)
  }
  object FlintFileDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDF: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[T](p: Rep[FlintFileDF[T]]): FlintFileDF[T] =
    proxyOps[FlintFileDF[T]](p)

  implicit class ExtendedFlintFileDF[T](p: Rep[FlintFileDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlintFileDFData[T]] = isoFlintFileDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[T](implicit eT: Elem[T]): Iso[FlintFileDFData[T], FlintFileDF[T]] =
    cachedIso[FlintFileDFIso[T]](eT)

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]]
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsInputDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends InputDF[T](dataSourceId) with Def[InputDF[T]] {
    lazy val selfType = element[InputDF[T]]
  }
  // elem for concrete class
  class InputDFElem[T](val iso: Iso[InputDFData[T], InputDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, InputDF[T]]
    with ConcreteElem[InputDFData[T], InputDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDF[T]]
    }
  }

  // state representation type
  type InputDFData[T] = String

  // 3) Iso for concrete class
  class InputDFIso[T](implicit eT: Elem[T])
    extends Iso[InputDFData[T], InputDF[T]] {
    override def from(p: Rep[InputDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eTo = new InputDFElem[T](this)
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
      mkInputDF(dataSourceId)
  }
  object InputDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkInputDF(p)
  }
  lazy val InputDF: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[T](p: Rep[InputDF[T]]): InputDF[T] =
    proxyOps[InputDF[T]](p)

  implicit class ExtendedInputDF[T](p: Rep[InputDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[InputDFData[T]] = isoInputDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[T](implicit eT: Elem[T]): Iso[InputDFData[T], InputDF[T]] =
    cachedIso[InputDFIso[T]](eT)

  // 6) smart constructor and deconstructor
  def mkInputDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]]
  def unmkInputDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsPhysicalRddDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends PhysicalRddDF[T](dataSourceId) with Def[PhysicalRddDF[T]] {
    lazy val selfType = element[PhysicalRddDF[T]]
  }
  // elem for concrete class
  class PhysicalRddDFElem[T](val iso: Iso[PhysicalRddDFData[T], PhysicalRddDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, PhysicalRddDF[T]]
    with ConcreteElem[PhysicalRddDFData[T], PhysicalRddDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PhysicalRddDF: missing fields List(dataSourceId)")
    override def getDefaultRep = PhysicalRddDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDF[T]]
    }
  }

  // state representation type
  type PhysicalRddDFData[T] = String

  // 3) Iso for concrete class
  class PhysicalRddDFIso[T](implicit eT: Elem[T])
    extends Iso[PhysicalRddDFData[T], PhysicalRddDF[T]] {
    override def from(p: Rep[PhysicalRddDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      PhysicalRddDF(dataSourceId)
    }
    lazy val eTo = new PhysicalRddDFElem[T](this)
  }
  // 4) constructor and deconstructor
  class PhysicalRddDFCompanionAbs extends CompanionDef[PhysicalRddDFCompanionAbs] with PhysicalRddDFCompanion {
    def selfType = PhysicalRddDFCompanionElem
    override def toString = "PhysicalRddDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
      mkPhysicalRddDF(dataSourceId)
  }
  object PhysicalRddDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkPhysicalRddDF(p)
  }
  lazy val PhysicalRddDF: Rep[PhysicalRddDFCompanionAbs] = new PhysicalRddDFCompanionAbs
  implicit def proxyPhysicalRddDFCompanion(p: Rep[PhysicalRddDFCompanionAbs]): PhysicalRddDFCompanionAbs = {
    proxyOps[PhysicalRddDFCompanionAbs](p)
  }

  implicit case object PhysicalRddDFCompanionElem extends CompanionElem[PhysicalRddDFCompanionAbs] {
    lazy val tag = weakTypeTag[PhysicalRddDFCompanionAbs]
    protected def getDefaultRep = PhysicalRddDF
  }

  implicit def proxyPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]]): PhysicalRddDF[T] =
    proxyOps[PhysicalRddDF[T]](p)

  implicit class ExtendedPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[PhysicalRddDFData[T]] = isoPhysicalRddDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPhysicalRddDF[T](implicit eT: Elem[T]): Iso[PhysicalRddDFData[T], PhysicalRddDF[T]] =
    cachedIso[PhysicalRddDFIso[T]](eT)

  // 6) smart constructor and deconstructor
  def mkPhysicalRddDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]]
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  registerModule(DataFrames_Module)
}

// Seq -----------------------------------
trait DataFramesSeq extends DataFramesDsl with ScalanSeq {
  self: DataFramesDslSeq =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class SeqFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName) {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new SeqFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: FlintFileDF[T] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class SeqInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId) {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new SeqInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: InputDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId) {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new SeqPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: PhysicalRddDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends DataFramesDsl with ScalanExp {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new ExpFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[T] @unchecked =>
      Some((p.asRep[FlintFileDF[T]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new ExpInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[T] @unchecked =>
      Some((p.asRep[InputDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId)

  object PhysicalRddDFMethods {
  }

  object PhysicalRddDFCompanionMethods {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new ExpPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PhysicalRddDFElem[T] @unchecked =>
      Some((p.asRep[PhysicalRddDF[T]].dataSourceId))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAO1Xz28bRRSeXcdxbIc0RFVFK1WkxvwGO0VCPeRQpY6NgkwSZQNCpkIa746dKbOzm51xZHPoHwA3xIELgh6ReuOEkCokhIQ4cEKAxJlTW4QqoCcQb8a7693Ebt1K5IQPo93Zt+/H933vzfr6bZQVAXpK2JhhXnGJxBVLX68JWbbqXFI5eM1zeoysk85j3lefnv/szBcmOtFCs3tYrAvWQvnhRb3vx9cW2W+iPOY2EdILhETnmjpC1fYYI7akHq9S1+1J3Gak2qRCrjbRTNtzBvvoKjKaaNH2uB0QSawaw0IQEe7PEZURje/z+n6w5Y9i8KqqopqoYjfAVEL6EGNxaL9DfGvAPT5wJVoIU9vyVVpgk6Ou7wUyCpEDd3ueE93OcAwbaKl5BR/gKoToVi0ZUN6FN4s+tt/BXbIJJsp8BhIWhHV2B76+zzRRQZB9AGjD9Zne6fsIIWDgJZ1EZYRPJcanovApWySgmNF3sXq4HXj9ARr+jAxCfR9cvHAfF5EHUudO+b3L9lt3raJrqpf7KpWcrnAWHD0+QQ2aCsDx250PxJ1Xrl0wUaGFClSstYUMsC2TlIdoFTHnntQ5xwDioAtslSaxpaOsgc0hSeRtz/UxB08hlPPAE6M2lcpY7c2H7EyAPid9Epkafd+I612eUK/WTQ0ztn3z9ItP3qq/aSIzHSIPLi0QfhA5lSi/jiVuBGAT+lfrCYmMXQ2yWvL9aHOhwSiX07wxWnP3yDjG7umbvznfrKDLZox4mOB0JIOLrPj5x+IPz1400VxLt0SD4W4LQBd1RtytoOZx2UJz3gEJhk9yB5ipq7Gk5xzSwT0mQyqSGGYAQ4mWJzavTxTAq7pRjAiA4lDrmx4n5cZ2+S/ruw+vKykHaH74ZNjN/9ALf/+y0JFa5RLNdSjTzRlBnIFBECPyxCQZ+GQ7oC6MnQPy8tdfvv77jc2sVsJSWNQbmPXIcAiENY3qU2HNUkmi2ZHBYTYLw5QtzyWPlu7Qt6+9LzVvRj89Z7baV6CxV/V75+5BYTTv/mytmH+c/ukTE+WBqTaVLvbLK1N26X/YeSit84VaOOu19M6nHxZ1hzSAt/XG+HaIlxJAfTJhXktmXRqNuDOJCGeNSFTaCLgiu1HoGSX0+7bk0RRLsaLOTlYUwHFqp3mS3b54w0TZV1G2A60jmijb9nrciXCGU1CSvrwU7RlpnAFXDHMjxlX/ltGo3nFjp2ikazqGgXUEdXQI9XkHPFpeL7DJhnO0OdXyzHi3z+u18iCSym1wvyenktNiaHpcUkqmVkrYX/qf2qmofWR7byAoNNqO40xF8KnUC8dF89E0H4zsBHGzY0HKwPR/CCmMxypFRhrCGMel2P0YDFNfRQ9brVo/GtmEhoVRWTI8+nmlo4QcZh1AsPFD2ArPKIDq6t2PN5/7/vNf9aleUKcdfFfw+B9A8jQ/pLdRePioT+QMWlBnoM73X0MRGOFkDQAA"
}
}

