package scalan.flint

import scalan._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends Scalan with DataFrames {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[T](p: Rep[DataFrame[T]]): DataFrame[T] = {
    proxyOps[DataFrame[T]](p)(scala.reflect.classTag[DataFrame[T]])
  }

  // familyElem
  class DataFrameElem[T, To <: DataFrame[T]](implicit _eT: Elem[T])
    extends EntityElem[To] {
    def eT = _eT
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[DataFrame[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[T]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[T]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[T]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[T](implicit eT: Elem[T]): Elem[DataFrame[T]] =
    cachedElem[DataFrameElem[T, DataFrame[T]]](eT)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanionAbs(p: Rep[DataFrameCompanionAbs]): DataFrameCompanionAbs =
    proxyOps[DataFrameCompanionAbs](p)

  abstract class AbsFlintFileDF[T]
      (fileName: Rep[String])(implicit eT: Elem[T])
    extends FlintFileDF[T](fileName) with Def[FlintFileDF[T]] {
    lazy val selfType = element[FlintFileDF[T]]
  }
  // elem for concrete class
  class FlintFileDFElem[T](val iso: Iso[FlintFileDFData[T], FlintFileDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, FlintFileDF[T]]
    with ConcreteElem[FlintFileDFData[T], FlintFileDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDF[T]]
    }
  }

  // state representation type
  type FlintFileDFData[T] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[T](implicit eT: Elem[T])
    extends EntityIso[FlintFileDFData[T], FlintFileDF[T]] with Def[FlintFileDFIso[T]] {
    override def from(p: Rep[FlintFileDF[T]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new FlintFileDFElem[T](self)
    lazy val selfType = new FlintFileDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class FlintFileDFIsoElem[T](eT: Elem[T]) extends Elem[FlintFileDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new FlintFileDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    def apply[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
      mkFlintFileDF(fileName)
  }
  object FlintFileDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDF: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[T](p: Rep[FlintFileDF[T]]): FlintFileDF[T] =
    proxyOps[FlintFileDF[T]](p)

  implicit class ExtendedFlintFileDF[T](p: Rep[FlintFileDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlintFileDFData[T]] = isoFlintFileDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[T](implicit eT: Elem[T]): Iso[FlintFileDFData[T], FlintFileDF[T]] =
    reifyObject(new FlintFileDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]]
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsInputDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends InputDF[T](dataSourceId) with Def[InputDF[T]] {
    lazy val selfType = element[InputDF[T]]
  }
  // elem for concrete class
  class InputDFElem[T](val iso: Iso[InputDFData[T], InputDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, InputDF[T]]
    with ConcreteElem[InputDFData[T], InputDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDF[T]]
    }
  }

  // state representation type
  type InputDFData[T] = String

  // 3) Iso for concrete class
  class InputDFIso[T](implicit eT: Elem[T])
    extends EntityIso[InputDFData[T], InputDF[T]] with Def[InputDFIso[T]] {
    override def from(p: Rep[InputDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new InputDFElem[T](self)
    lazy val selfType = new InputDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class InputDFIsoElem[T](eT: Elem[T]) extends Elem[InputDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new InputDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
      mkInputDF(dataSourceId)
  }
  object InputDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkInputDF(p)
  }
  lazy val InputDF: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[T](p: Rep[InputDF[T]]): InputDF[T] =
    proxyOps[InputDF[T]](p)

  implicit class ExtendedInputDF[T](p: Rep[InputDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[InputDFData[T]] = isoInputDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[T](implicit eT: Elem[T]): Iso[InputDFData[T], InputDF[T]] =
    reifyObject(new InputDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkInputDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]]
  def unmkInputDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsPhysicalRddDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends PhysicalRddDF[T](dataSourceId) with Def[PhysicalRddDF[T]] {
    lazy val selfType = element[PhysicalRddDF[T]]
  }
  // elem for concrete class
  class PhysicalRddDFElem[T](val iso: Iso[PhysicalRddDFData[T], PhysicalRddDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, PhysicalRddDF[T]]
    with ConcreteElem[PhysicalRddDFData[T], PhysicalRddDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PhysicalRddDF: missing fields List(dataSourceId)")
    override def getDefaultRep = PhysicalRddDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDF[T]]
    }
  }

  // state representation type
  type PhysicalRddDFData[T] = String

  // 3) Iso for concrete class
  class PhysicalRddDFIso[T](implicit eT: Elem[T])
    extends EntityIso[PhysicalRddDFData[T], PhysicalRddDF[T]] with Def[PhysicalRddDFIso[T]] {
    override def from(p: Rep[PhysicalRddDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      PhysicalRddDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new PhysicalRddDFElem[T](self)
    lazy val selfType = new PhysicalRddDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class PhysicalRddDFIsoElem[T](eT: Elem[T]) extends Elem[PhysicalRddDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PhysicalRddDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class PhysicalRddDFCompanionAbs extends CompanionDef[PhysicalRddDFCompanionAbs] with PhysicalRddDFCompanion {
    def selfType = PhysicalRddDFCompanionElem
    override def toString = "PhysicalRddDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
      mkPhysicalRddDF(dataSourceId)
  }
  object PhysicalRddDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkPhysicalRddDF(p)
  }
  lazy val PhysicalRddDF: Rep[PhysicalRddDFCompanionAbs] = new PhysicalRddDFCompanionAbs
  implicit def proxyPhysicalRddDFCompanion(p: Rep[PhysicalRddDFCompanionAbs]): PhysicalRddDFCompanionAbs = {
    proxyOps[PhysicalRddDFCompanionAbs](p)
  }

  implicit case object PhysicalRddDFCompanionElem extends CompanionElem[PhysicalRddDFCompanionAbs] {
    lazy val tag = weakTypeTag[PhysicalRddDFCompanionAbs]
    protected def getDefaultRep = PhysicalRddDF
  }

  implicit def proxyPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]]): PhysicalRddDF[T] =
    proxyOps[PhysicalRddDF[T]](p)

  implicit class ExtendedPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[PhysicalRddDFData[T]] = isoPhysicalRddDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPhysicalRddDF[T](implicit eT: Elem[T]): Iso[PhysicalRddDFData[T], PhysicalRddDF[T]] =
    reifyObject(new PhysicalRddDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkPhysicalRddDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]]
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsArrayDF[T]
      (records: Rep[Array[T]])(implicit eT: Elem[T])
    extends ArrayDF[T](records) with Def[ArrayDF[T]] {
    lazy val selfType = element[ArrayDF[T]]
  }
  // elem for concrete class
  class ArrayDFElem[T](val iso: Iso[ArrayDFData[T], ArrayDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, ArrayDF[T]]
    with ConcreteElem[ArrayDFData[T], ArrayDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ArrayDF: missing fields List(records)")
    override def getDefaultRep = ArrayDF(element[Array[T]].defaultRepValue)
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ArrayDF[T]]
    }
  }

  // state representation type
  type ArrayDFData[T] = Array[T]

  // 3) Iso for concrete class
  class ArrayDFIso[T](implicit eT: Elem[T])
    extends EntityIso[ArrayDFData[T], ArrayDF[T]] with Def[ArrayDFIso[T]] {
    override def from(p: Rep[ArrayDF[T]]) =
      p.records
    override def to(p: Rep[Array[T]]) = {
      val records = p
      ArrayDF(records)
    }
    lazy val eFrom = element[Array[T]]
    lazy val eTo = new ArrayDFElem[T](self)
    lazy val selfType = new ArrayDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class ArrayDFIsoElem[T](eT: Elem[T]) extends Elem[ArrayDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ArrayDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ArrayDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class ArrayDFCompanionAbs extends CompanionDef[ArrayDFCompanionAbs] with ArrayDFCompanion {
    def selfType = ArrayDFCompanionElem
    override def toString = "ArrayDF"

    def apply[T](records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
      mkArrayDF(records)
  }
  object ArrayDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkArrayDF(p)
  }
  lazy val ArrayDF: Rep[ArrayDFCompanionAbs] = new ArrayDFCompanionAbs
  implicit def proxyArrayDFCompanion(p: Rep[ArrayDFCompanionAbs]): ArrayDFCompanionAbs = {
    proxyOps[ArrayDFCompanionAbs](p)
  }

  implicit case object ArrayDFCompanionElem extends CompanionElem[ArrayDFCompanionAbs] {
    lazy val tag = weakTypeTag[ArrayDFCompanionAbs]
    protected def getDefaultRep = ArrayDF
  }

  implicit def proxyArrayDF[T](p: Rep[ArrayDF[T]]): ArrayDF[T] =
    proxyOps[ArrayDF[T]](p)

  implicit class ExtendedArrayDF[T](p: Rep[ArrayDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[ArrayDFData[T]] = isoArrayDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoArrayDF[T](implicit eT: Elem[T]): Iso[ArrayDFData[T], ArrayDF[T]] =
    reifyObject(new ArrayDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkArrayDF[T](records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]]
  def unmkArrayDF[T](p: Rep[DataFrame[T]]): Option[(Rep[Array[T]])]

  abstract class AbsPairDF[L, R]
      (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends PairDF[L, R](left, right) with Def[PairDF[L, R]] {
    lazy val selfType = element[PairDF[L, R]]
  }
  // elem for concrete class
  class PairDFElem[L, R](val iso: Iso[PairDFData[L, R], PairDF[L, R]])(implicit eL: Elem[L], eR: Elem[R])
    extends DataFrameElem[(L, R), PairDF[L, R]]
    with ConcreteElem[PairDFData[L, R], PairDF[L, R]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(pairElement(element[L],element[R])))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("L" -> Left(eL), "R" -> Left(eR))
    }

    override def convertDataFrame(x: Rep[DataFrame[(L, R)]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PairDF: missing fields List(left, right)")
    override def getDefaultRep = PairDF(element[DataFrame[L]].defaultRepValue, element[DataFrame[R]].defaultRepValue)
    override lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[PairDF[L, R]]
    }
  }

  // state representation type
  type PairDFData[L, R] = (DataFrame[L], DataFrame[R])

  // 3) Iso for concrete class
  class PairDFIso[L, R](implicit eL: Elem[L], eR: Elem[R])
    extends EntityIso[PairDFData[L, R], PairDF[L, R]] with Def[PairDFIso[L, R]] {
    override def from(p: Rep[PairDF[L, R]]) =
      (p.left, p.right)
    override def to(p: Rep[(DataFrame[L], DataFrame[R])]) = {
      val Pair(left, right) = p
      PairDF(left, right)
    }
    lazy val eFrom = pairElement(element[DataFrame[L]], element[DataFrame[R]])
    lazy val eTo = new PairDFElem[L, R](self)
    lazy val selfType = new PairDFIsoElem[L, R](eL, eR)
    def productArity = 2
    def productElement(n: Int) = (eL, eR).productElement(n)
  }
  case class PairDFIsoElem[L, R](eL: Elem[L], eR: Elem[R]) extends Elem[PairDFIso[L, R]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PairDFIso[L, R]()(eL, eR))
    lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[PairDFIso[L, R]]
    }
  }
  // 4) constructor and deconstructor
  class PairDFCompanionAbs extends CompanionDef[PairDFCompanionAbs] with PairDFCompanion {
    def selfType = PairDFCompanionElem
    override def toString = "PairDF"
    def apply[L, R](p: Rep[PairDFData[L, R]])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
      isoPairDF(eL, eR).to(p)
    def apply[L, R](left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
      mkPairDF(left, right)
  }
  object PairDFMatcher {
    def unapply[L, R](p: Rep[DataFrame[(L, R)]]) = unmkPairDF(p)
  }
  lazy val PairDF: Rep[PairDFCompanionAbs] = new PairDFCompanionAbs
  implicit def proxyPairDFCompanion(p: Rep[PairDFCompanionAbs]): PairDFCompanionAbs = {
    proxyOps[PairDFCompanionAbs](p)
  }

  implicit case object PairDFCompanionElem extends CompanionElem[PairDFCompanionAbs] {
    lazy val tag = weakTypeTag[PairDFCompanionAbs]
    protected def getDefaultRep = PairDF
  }

  implicit def proxyPairDF[L, R](p: Rep[PairDF[L, R]]): PairDF[L, R] =
    proxyOps[PairDF[L, R]](p)

  implicit class ExtendedPairDF[L, R](p: Rep[PairDF[L, R]])(implicit eL: Elem[L], eR: Elem[R]) {
    def toData: Rep[PairDFData[L, R]] = isoPairDF(eL, eR).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPairDF[L, R](implicit eL: Elem[L], eR: Elem[R]): Iso[PairDFData[L, R], PairDF[L, R]] =
    reifyObject(new PairDFIso[L, R]()(eL, eR))

  // 6) smart constructor and deconstructor
  def mkPairDF[L, R](left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]]
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]): Option[(Rep[DataFrame[L]], Rep[DataFrame[R]])]

  abstract class AbsShardedDF[T]
      (nShards: Rep[Int], distrib: Rep[T => Int], shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T])
    extends ShardedDF[T](nShards, distrib, shards) with Def[ShardedDF[T]] {
    lazy val selfType = element[ShardedDF[T]]
  }
  // elem for concrete class
  class ShardedDFElem[T](val iso: Iso[ShardedDFData[T], ShardedDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, ShardedDF[T]]
    with ConcreteElem[ShardedDFData[T], ShardedDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ShardedDF: missing fields List(nShards, distrib, shards)")
    override def getDefaultRep = ShardedDF(0, constFun[T, Int](0), element[Array[DataFrame[T]]].defaultRepValue)
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ShardedDF[T]]
    }
  }

  // state representation type
  type ShardedDFData[T] = (Int, (T => Int, Array[DataFrame[T]]))

  // 3) Iso for concrete class
  class ShardedDFIso[T](implicit eT: Elem[T])
    extends EntityIso[ShardedDFData[T], ShardedDF[T]] with Def[ShardedDFIso[T]] {
    override def from(p: Rep[ShardedDF[T]]) =
      (p.nShards, p.distrib, p.shards)
    override def to(p: Rep[(Int, (T => Int, Array[DataFrame[T]]))]) = {
      val Pair(nShards, Pair(distrib, shards)) = p
      ShardedDF(nShards, distrib, shards)
    }
    lazy val eFrom = pairElement(element[Int], pairElement(element[T => Int], element[Array[DataFrame[T]]]))
    lazy val eTo = new ShardedDFElem[T](self)
    lazy val selfType = new ShardedDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class ShardedDFIsoElem[T](eT: Elem[T]) extends Elem[ShardedDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ShardedDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ShardedDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class ShardedDFCompanionAbs extends CompanionDef[ShardedDFCompanionAbs] with ShardedDFCompanion {
    def selfType = ShardedDFCompanionElem
    override def toString = "ShardedDF"
    def apply[T](p: Rep[ShardedDFData[T]])(implicit eT: Elem[T]): Rep[ShardedDF[T]] =
      isoShardedDF(eT).to(p)
    def apply[T](nShards: Rep[Int], distrib: Rep[T => Int], shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T]): Rep[ShardedDF[T]] =
      mkShardedDF(nShards, distrib, shards)
  }
  object ShardedDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkShardedDF(p)
  }
  lazy val ShardedDF: Rep[ShardedDFCompanionAbs] = new ShardedDFCompanionAbs
  implicit def proxyShardedDFCompanion(p: Rep[ShardedDFCompanionAbs]): ShardedDFCompanionAbs = {
    proxyOps[ShardedDFCompanionAbs](p)
  }

  implicit case object ShardedDFCompanionElem extends CompanionElem[ShardedDFCompanionAbs] {
    lazy val tag = weakTypeTag[ShardedDFCompanionAbs]
    protected def getDefaultRep = ShardedDF
  }

  implicit def proxyShardedDF[T](p: Rep[ShardedDF[T]]): ShardedDF[T] =
    proxyOps[ShardedDF[T]](p)

  implicit class ExtendedShardedDF[T](p: Rep[ShardedDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[ShardedDFData[T]] = isoShardedDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoShardedDF[T](implicit eT: Elem[T]): Iso[ShardedDFData[T], ShardedDF[T]] =
    reifyObject(new ShardedDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkShardedDF[T](nShards: Rep[Int], distrib: Rep[T => Int], shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T]): Rep[ShardedDF[T]]
  def unmkShardedDF[T](p: Rep[DataFrame[T]]): Option[(Rep[Int], Rep[T => Int], Rep[Array[DataFrame[T]]])]

  abstract class AbsShardedViewDF[T]
      (nShards: Rep[Int], view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T])
    extends ShardedViewDF[T](nShards, view) with Def[ShardedViewDF[T]] {
    lazy val selfType = element[ShardedViewDF[T]]
  }
  // elem for concrete class
  class ShardedViewDFElem[T](val iso: Iso[ShardedViewDFData[T], ShardedViewDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, ShardedViewDF[T]]
    with ConcreteElem[ShardedViewDFData[T], ShardedViewDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ShardedViewDF: missing fields List(nShards, view)")
    override def getDefaultRep = ShardedViewDF(0, constFun[Int, DataFrame[T]](element[DataFrame[T]].defaultRepValue))
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ShardedViewDF[T]]
    }
  }

  // state representation type
  type ShardedViewDFData[T] = (Int, Int => DataFrame[T])

  // 3) Iso for concrete class
  class ShardedViewDFIso[T](implicit eT: Elem[T])
    extends EntityIso[ShardedViewDFData[T], ShardedViewDF[T]] with Def[ShardedViewDFIso[T]] {
    override def from(p: Rep[ShardedViewDF[T]]) =
      (p.nShards, p.view)
    override def to(p: Rep[(Int, Int => DataFrame[T])]) = {
      val Pair(nShards, view) = p
      ShardedViewDF(nShards, view)
    }
    lazy val eFrom = pairElement(element[Int], element[Int => DataFrame[T]])
    lazy val eTo = new ShardedViewDFElem[T](self)
    lazy val selfType = new ShardedViewDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class ShardedViewDFIsoElem[T](eT: Elem[T]) extends Elem[ShardedViewDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ShardedViewDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ShardedViewDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class ShardedViewDFCompanionAbs extends CompanionDef[ShardedViewDFCompanionAbs] with ShardedViewDFCompanion {
    def selfType = ShardedViewDFCompanionElem
    override def toString = "ShardedViewDF"
    def apply[T](p: Rep[ShardedViewDFData[T]])(implicit eT: Elem[T]): Rep[ShardedViewDF[T]] =
      isoShardedViewDF(eT).to(p)
    def apply[T](nShards: Rep[Int], view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T]): Rep[ShardedViewDF[T]] =
      mkShardedViewDF(nShards, view)
  }
  object ShardedViewDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkShardedViewDF(p)
  }
  lazy val ShardedViewDF: Rep[ShardedViewDFCompanionAbs] = new ShardedViewDFCompanionAbs
  implicit def proxyShardedViewDFCompanion(p: Rep[ShardedViewDFCompanionAbs]): ShardedViewDFCompanionAbs = {
    proxyOps[ShardedViewDFCompanionAbs](p)
  }

  implicit case object ShardedViewDFCompanionElem extends CompanionElem[ShardedViewDFCompanionAbs] {
    lazy val tag = weakTypeTag[ShardedViewDFCompanionAbs]
    protected def getDefaultRep = ShardedViewDF
  }

  implicit def proxyShardedViewDF[T](p: Rep[ShardedViewDF[T]]): ShardedViewDF[T] =
    proxyOps[ShardedViewDF[T]](p)

  implicit class ExtendedShardedViewDF[T](p: Rep[ShardedViewDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[ShardedViewDFData[T]] = isoShardedViewDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoShardedViewDF[T](implicit eT: Elem[T]): Iso[ShardedViewDFData[T], ShardedViewDF[T]] =
    reifyObject(new ShardedViewDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkShardedViewDF[T](nShards: Rep[Int], view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T]): Rep[ShardedViewDF[T]]
  def unmkShardedViewDF[T](p: Rep[DataFrame[T]]): Option[(Rep[Int], Rep[Int => DataFrame[T]])]

  registerModule(DataFrames_Module)
}

// Seq -----------------------------------
trait DataFramesSeq extends ScalanSeq with DataFramesDsl {
  self: DataFramesDslSeq =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class SeqFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName) {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new SeqFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: FlintFileDF[T] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class SeqInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId) {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new SeqInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: InputDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId) {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new SeqPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: PhysicalRddDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqArrayDF[T]
      (override val records: Rep[Array[T]])(implicit eT: Elem[T])
    extends AbsArrayDF[T](records) {
  }

  def mkArrayDF[T]
    (records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
    new SeqArrayDF[T](records)
  def unmkArrayDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: ArrayDF[T] @unchecked =>
      Some((p.records))
    case _ => None
  }

  case class SeqPairDF[L, R]
      (override val left: DF[L], override val right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends AbsPairDF[L, R](left, right) {
  }

  def mkPairDF[L, R]
    (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
    new SeqPairDF[L, R](left, right)
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]) = p match {
    case p: PairDF[L, R] @unchecked =>
      Some((p.left, p.right))
    case _ => None
  }

  case class SeqShardedDF[T]
      (override val nShards: Rep[Int], override val distrib: Rep[T => Int], override val shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T])
    extends AbsShardedDF[T](nShards, distrib, shards) {
  }

  def mkShardedDF[T]
    (nShards: Rep[Int], distrib: Rep[T => Int], shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T]): Rep[ShardedDF[T]] =
    new SeqShardedDF[T](nShards, distrib, shards)
  def unmkShardedDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: ShardedDF[T] @unchecked =>
      Some((p.nShards, p.distrib, p.shards))
    case _ => None
  }

  case class SeqShardedViewDF[T]
      (override val nShards: Rep[Int], override val view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T])
    extends AbsShardedViewDF[T](nShards, view) {
  }

  def mkShardedViewDF[T]
    (nShards: Rep[Int], view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T]): Rep[ShardedViewDF[T]] =
    new SeqShardedViewDF[T](nShards, view)
  def unmkShardedViewDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: ShardedViewDF[T] @unchecked =>
      Some((p.nShards, p.view))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends ScalanExp with DataFramesDsl {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new ExpFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[T] @unchecked =>
      Some((p.asRep[FlintFileDF[T]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new ExpInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[T] @unchecked =>
      Some((p.asRep[InputDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId)

  object PhysicalRddDFMethods {
  }

  object PhysicalRddDFCompanionMethods {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new ExpPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PhysicalRddDFElem[T] @unchecked =>
      Some((p.asRep[PhysicalRddDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpArrayDF[T]
      (override val records: Rep[Array[T]])(implicit eT: Elem[T])
    extends AbsArrayDF[T](records)

  object ArrayDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ArrayDF[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ArrayDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[Rep[Array[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(arr, _*), _) if receiver.elem == ArrayDFCompanionElem && method.getName == "create" =>
          Some(arr).asInstanceOf[Option[Rep[Array[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Array[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkArrayDF[T]
    (records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
    new ExpArrayDF[T](records)
  def unmkArrayDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ArrayDFElem[T] @unchecked =>
      Some((p.asRep[ArrayDF[T]].records))
    case _ =>
      None
  }

  case class ExpPairDF[L, R]
      (override val left: DF[L], override val right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends AbsPairDF[L, R](left, right)

  object PairDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[PairDF[L, R]] forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[PairDFElem[_, _]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[PairDF[L, R]] forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[PairDF[L, R]] forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object PairDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[(DF[L], DF[R]) forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, Seq(left, right, _*), _) if receiver.elem == PairDFCompanionElem && method.getName == "create" =>
          Some((left, right)).asInstanceOf[Option[(DF[L], DF[R]) forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(DF[L], DF[R]) forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkPairDF[L, R]
    (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
    new ExpPairDF[L, R](left, right)
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PairDFElem[L, R] @unchecked =>
      Some((p.asRep[PairDF[L, R]].left, p.asRep[PairDF[L, R]].right))
    case _ =>
      None
  }

  case class ExpShardedDF[T]
      (override val nShards: Rep[Int], override val distrib: Rep[T => Int], override val shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T])
    extends AbsShardedDF[T](nShards, distrib, shards)

  object ShardedDFMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[ShardedDF[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[ShardedDFElem[_]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[ShardedDF[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ShardedDF[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object toArray {
      def unapply(d: Def[_]): Option[Rep[ShardedDF[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ShardedDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ShardedDF[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ShardedDF[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ShardedDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[(Rep[Int], Rep[Int => DataFrame[T]], Rep[T => Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(nShards, createShard, distrib, _*), _) if receiver.elem == ShardedDFCompanionElem && method.getName == "create" =>
          Some((nShards, createShard, distrib)).asInstanceOf[Option[(Rep[Int], Rep[Int => DataFrame[T]], Rep[T => Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Int], Rep[Int => DataFrame[T]], Rep[T => Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkShardedDF[T]
    (nShards: Rep[Int], distrib: Rep[T => Int], shards: Rep[Array[DataFrame[T]]])(implicit eT: Elem[T]): Rep[ShardedDF[T]] =
    new ExpShardedDF[T](nShards, distrib, shards)
  def unmkShardedDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ShardedDFElem[T] @unchecked =>
      Some((p.asRep[ShardedDF[T]].nShards, p.asRep[ShardedDF[T]].distrib, p.asRep[ShardedDF[T]].shards))
    case _ =>
      None
  }

  case class ExpShardedViewDF[T]
      (override val nShards: Rep[Int], override val view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T])
    extends AbsShardedViewDF[T](nShards, view)

  object ShardedViewDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[ShardedViewDF[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ShardedViewDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ShardedViewDF[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ShardedViewDF[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ShardedViewDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[(Rep[Int], Rep[Int => DataFrame[T]]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(nShards, view, _*), _) if receiver.elem == ShardedViewDFCompanionElem && method.getName == "create" =>
          Some((nShards, view)).asInstanceOf[Option[(Rep[Int], Rep[Int => DataFrame[T]]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Int], Rep[Int => DataFrame[T]]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkShardedViewDF[T]
    (nShards: Rep[Int], view: Rep[Int => DataFrame[T]])(implicit eT: Elem[T]): Rep[ShardedViewDF[T]] =
    new ExpShardedViewDF[T](nShards, view)
  def unmkShardedViewDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ShardedViewDFElem[T] @unchecked =>
      Some((p.asRep[ShardedViewDF[T]].nShards, p.asRep[ShardedViewDF[T]].view))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep

    object toArray {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAO1YS2wbRRgeO37EcUhCWiqolJCYQCkPO61APeRQhTiGIJNY3lChULUa746dKbuzm9lxsDlUnAqCG+LCAYlKXJB6QZxQpQoJISEOPVUIiRMHTqWo6oGKA4iZ8e5612s7cdpaIOHDyjs78z++7/v/nZ0rt0DcpuApW4U6JFkDMZhV5P9lmy0oq4Rh1nzN1Oo6yqPqo+Y3n5344ujXUTC5BRLb0M7b+hZItf6sNizvv4J2iiAFiYpsZlKbgfmi9JBTTV1HKsMmyWHDqDNY0VGuiG22VASxiqk1d8BFECmCKdUkKkUMKSs6tG1kO+OjSESEvfuUvG9uWG0fJCeyyPmy2KQQMx4+9zHVml9GltIkJmkaDEw4oW1YIiw+J4kNy6TMdZHk5rZNzb2NEcgHwHTxAtyFOe6illMYxaTGV6YtqL4Fa2idTxHTYzxgG+nVzaYl70eKYMxGOxygNcPS5UjDAgBwBk7KILJtfLIePlmBz4KCKIY6fgeKhyVqNpqg9YuMANCwuInn9jDhWkCrRFv44Kz65l0lbUTF4oYIJSkzTHBDj/dQg6SC4/h9+SP7zsuXT0XB2BYYw/ZyxWYUqsxPuYNWGhJiMhmzByCkNc5Wphdb0ssyn9MhiZRqGhYk3JID5TjnSccqZmKyGBt32OkBfZJZyJ0aaVgRL9+5HvlK3axAXS/dfOz5J39bfSMKokEXKW5S4cKnrlEGUnnIYIHyOY59cZ1kILIpQRaXVMMdnCjomLD9rGhfk30i9rA7dvN37btFcDbqIe4EuD+SuYm4/dOP6RvHT0fB6JYsiYIOa1scdHtVR8YGXTEJ2wKj5i6irSfJXaiLf11JT2qoCus6c6jwYzjCMWRgrmfxWkgAvCQLJeICkG5pfd0kaKFQWvhD+eHjK0LKFIy3nrSq+W986q+fJ6pMqpyB0SrWZXG6EI/wRuAh8kQvGVioRLHB284uevHbq6/fvrYel0qYdpI6A/U6ajUBJ6d2fsJtNJNhINGe0MnmWCtkxTTQw5k7+NzlD5nkLdII9pmNygVe2Ety3XwfCt1+9+WlS4/c/vz8IVmnoxXMDGgtLA5QpW5RPcAqBEHNT6w4fV/K8ETwYVpWS4FzmC/0KA1xPeo9k5cMZ+Cwb+WKP4GMb5nP2UzE1ZqcxClEm24UMaH/PSs1HG3GE9pMb6FxZI6Ui4f1W6evRUH8VRCv8oqyiyBeMetEcyHnL0eGGuwldywShJxDDHk78SCWvznQzrdbN0pHgjkNoY+FUAcdqI9r3KJi1qmK1rRwzYrL093NPiuv2UHUlVwjVp0NqqwpZ9WwVOWPMuObv/I/y/ti+aHSdtPGvObKmjYo10cCa4fFeDjiYfOe3BR7yHzhfhGepEg1qWZ3eQs7I/FlSmFzX/7uteqlp4Gr3lk1tKr3Rfkg2O+zl7DQZt3S0QtX/zz3/ruvWHJjEtr2dqRQbCMhbsuhjPoo6/qgtgaSXkxHVeYai4YkXexELmQgTnFtu4+F7vHtX54ngw8TJYjpoOqcbC06oDiL/cQZBihsoNzPQBifQJJ7i9unh+4Typ0h/rt6H1G2Ye/ed4zbXuSja4T1U2FS49/zFFe6WKFgtncpF+pEvbH2yaHJmfO/yE+YhGYaEEuFzPJdJuWfGXIXOevUdCDXyHy/mBJ2v8R6NPV9cdGv2g/Q8lOSATTw63/aWzesth+M9D//2u8p/T21FdvF6O3uyoocl6vvSVAH3006BJ3h4Q28mwysHdpuMhTxYLLysZToitdIHlXvQ42HYAtQ1DHcrVg9p12QDRzTHRQDIbv32nOciWPtZJlzFkWyVfHd5CRAubPu/VlxDko4gBfvfrr+zPWvfpU9ekwcuZgEEe9I2n+81CHItvu8rfti5goRBzEy3n8AUKDMdPUXAAA="
}
}

