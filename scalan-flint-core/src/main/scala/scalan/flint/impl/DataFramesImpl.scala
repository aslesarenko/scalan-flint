package scalan.flint

import scalan._
import scalan.collections._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends Scalan with DataFrames {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[Row](p: Rep[DataFrame[Row]]): DataFrame[Row] = {
    proxyOps[DataFrame[Row]](p)(scala.reflect.classTag[DataFrame[Row]])
  }

  // familyElem
  class DataFrameElem[Row, To <: DataFrame[Row]](implicit _eRow: Elem[Row])
    extends EntityElem[To] {
    def eRow = _eRow
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[DataFrame[Row]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[Row]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[Row]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[Row]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[Row](implicit eRow: Elem[Row]): Elem[DataFrame[Row]] =
    cachedElem[DataFrameElem[Row, DataFrame[Row]]](eRow)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanionAbs(p: Rep[DataFrameCompanionAbs]): DataFrameCompanionAbs =
    proxyOps[DataFrameCompanionAbs](p)

  abstract class AbsFlintFileDF[Row]
      (fileName: Rep[String])(implicit eRow: Elem[Row])
    extends FlintFileDF[Row](fileName) with Def[FlintFileDF[Row]] {
    lazy val selfType = element[FlintFileDF[Row]]
  }
  // elem for concrete class
  class FlintFileDFElem[Row](val iso: Iso[FlintFileDFData[Row], FlintFileDF[Row]])(implicit override val eRow: Elem[Row])
    extends DataFrameElem[Row, FlintFileDF[Row]]
    with ConcreteElem[FlintFileDFData[Row], FlintFileDF[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[Row]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }

    override def convertDataFrame(x: Rep[DataFrame[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[FlintFileDF[Row]]
    }
  }

  // state representation type
  type FlintFileDFData[Row] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[FlintFileDFData[Row], FlintFileDF[Row]] with Def[FlintFileDFIso[Row]] {
    override def from(p: Rep[FlintFileDF[Row]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new FlintFileDFElem[Row](self)
    lazy val selfType = new FlintFileDFIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class FlintFileDFIsoElem[Row](eRow: Elem[Row]) extends Elem[FlintFileDFIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new FlintFileDFIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[FlintFileDFIso[Row]]
    }
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    @scalan.OverloadId("fromFields")
    def apply[Row](fileName: Rep[String])(implicit eRow: Elem[Row]): Rep[FlintFileDF[Row]] =
      mkFlintFileDF(fileName)

    def unapply[Row](p: Rep[DataFrame[Row]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDFRep: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  lazy val FlintFileDF: FlintFileDFCompanionAbs = proxyFlintFileDFCompanion(FlintFileDFRep)
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[Row](p: Rep[FlintFileDF[Row]]): FlintFileDF[Row] =
    proxyOps[FlintFileDF[Row]](p)

  implicit class ExtendedFlintFileDF[Row](p: Rep[FlintFileDF[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[FlintFileDFData[Row]] = isoFlintFileDF(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[Row](implicit eRow: Elem[Row]): Iso[FlintFileDFData[Row], FlintFileDF[Row]] =
    reifyObject(new FlintFileDFIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[Row](fileName: Rep[String])(implicit eRow: Elem[Row]): Rep[FlintFileDF[Row]]
  def unmkFlintFileDF[Row](p: Rep[DataFrame[Row]]): Option[(Rep[String])]

  abstract class AbsInputDF[Row]
      (dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends InputDF[Row](dataSourceId) with Def[InputDF[Row]] {
    lazy val selfType = element[InputDF[Row]]
  }
  // elem for concrete class
  class InputDFElem[Row](val iso: Iso[InputDFData[Row], InputDF[Row]])(implicit override val eRow: Elem[Row])
    extends DataFrameElem[Row, InputDF[Row]]
    with ConcreteElem[InputDFData[Row], InputDF[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[Row]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }

    override def convertDataFrame(x: Rep[DataFrame[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[InputDF[Row]]
    }
  }

  // state representation type
  type InputDFData[Row] = String

  // 3) Iso for concrete class
  class InputDFIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[InputDFData[Row], InputDF[Row]] with Def[InputDFIso[Row]] {
    override def from(p: Rep[InputDF[Row]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new InputDFElem[Row](self)
    lazy val selfType = new InputDFIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class InputDFIsoElem[Row](eRow: Elem[Row]) extends Elem[InputDFIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new InputDFIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[InputDFIso[Row]]
    }
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    @scalan.OverloadId("fromFields")
    def apply[Row](dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[InputDF[Row]] =
      mkInputDF(dataSourceId)

    def unapply[Row](p: Rep[DataFrame[Row]]) = unmkInputDF(p)
  }
  lazy val InputDFRep: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  lazy val InputDF: InputDFCompanionAbs = proxyInputDFCompanion(InputDFRep)
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[Row](p: Rep[InputDF[Row]]): InputDF[Row] =
    proxyOps[InputDF[Row]](p)

  implicit class ExtendedInputDF[Row](p: Rep[InputDF[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[InputDFData[Row]] = isoInputDF(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[Row](implicit eRow: Elem[Row]): Iso[InputDFData[Row], InputDF[Row]] =
    reifyObject(new InputDFIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkInputDF[Row](dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[InputDF[Row]]
  def unmkInputDF[Row](p: Rep[DataFrame[Row]]): Option[(Rep[String])]

  abstract class AbsPhysicalRddDF[Row]
      (dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends PhysicalRddDF[Row](dataSourceId) with Def[PhysicalRddDF[Row]] {
    lazy val selfType = element[PhysicalRddDF[Row]]
  }
  // elem for concrete class
  class PhysicalRddDFElem[Row](val iso: Iso[PhysicalRddDFData[Row], PhysicalRddDF[Row]])(implicit override val eRow: Elem[Row])
    extends DataFrameElem[Row, PhysicalRddDF[Row]]
    with ConcreteElem[PhysicalRddDFData[Row], PhysicalRddDF[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[Row]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }

    override def convertDataFrame(x: Rep[DataFrame[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PhysicalRddDF: missing fields List(dataSourceId)")
    override def getDefaultRep = PhysicalRddDF("")
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[PhysicalRddDF[Row]]
    }
  }

  // state representation type
  type PhysicalRddDFData[Row] = String

  // 3) Iso for concrete class
  class PhysicalRddDFIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[PhysicalRddDFData[Row], PhysicalRddDF[Row]] with Def[PhysicalRddDFIso[Row]] {
    override def from(p: Rep[PhysicalRddDF[Row]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      PhysicalRddDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new PhysicalRddDFElem[Row](self)
    lazy val selfType = new PhysicalRddDFIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class PhysicalRddDFIsoElem[Row](eRow: Elem[Row]) extends Elem[PhysicalRddDFIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PhysicalRddDFIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[PhysicalRddDFIso[Row]]
    }
  }
  // 4) constructor and deconstructor
  class PhysicalRddDFCompanionAbs extends CompanionDef[PhysicalRddDFCompanionAbs] with PhysicalRddDFCompanion {
    def selfType = PhysicalRddDFCompanionElem
    override def toString = "PhysicalRddDF"

    @scalan.OverloadId("fromFields")
    def apply[Row](dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[PhysicalRddDF[Row]] =
      mkPhysicalRddDF(dataSourceId)

    def unapply[Row](p: Rep[DataFrame[Row]]) = unmkPhysicalRddDF(p)
  }
  lazy val PhysicalRddDFRep: Rep[PhysicalRddDFCompanionAbs] = new PhysicalRddDFCompanionAbs
  lazy val PhysicalRddDF: PhysicalRddDFCompanionAbs = proxyPhysicalRddDFCompanion(PhysicalRddDFRep)
  implicit def proxyPhysicalRddDFCompanion(p: Rep[PhysicalRddDFCompanionAbs]): PhysicalRddDFCompanionAbs = {
    proxyOps[PhysicalRddDFCompanionAbs](p)
  }

  implicit case object PhysicalRddDFCompanionElem extends CompanionElem[PhysicalRddDFCompanionAbs] {
    lazy val tag = weakTypeTag[PhysicalRddDFCompanionAbs]
    protected def getDefaultRep = PhysicalRddDF
  }

  implicit def proxyPhysicalRddDF[Row](p: Rep[PhysicalRddDF[Row]]): PhysicalRddDF[Row] =
    proxyOps[PhysicalRddDF[Row]](p)

  implicit class ExtendedPhysicalRddDF[Row](p: Rep[PhysicalRddDF[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[PhysicalRddDFData[Row]] = isoPhysicalRddDF(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPhysicalRddDF[Row](implicit eRow: Elem[Row]): Iso[PhysicalRddDFData[Row], PhysicalRddDF[Row]] =
    reifyObject(new PhysicalRddDFIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkPhysicalRddDF[Row](dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[PhysicalRddDF[Row]]
  def unmkPhysicalRddDF[Row](p: Rep[DataFrame[Row]]): Option[(Rep[String])]

  abstract class AbsArrayDF[Row]
      (records: Rep[Array[Row]])(implicit eRow: Elem[Row])
    extends ArrayDF[Row](records) with Def[ArrayDF[Row]] {
    lazy val selfType = element[ArrayDF[Row]]
  }
  // elem for concrete class
  class ArrayDFElem[Row](val iso: Iso[ArrayDFData[Row], ArrayDF[Row]])(implicit override val eRow: Elem[Row])
    extends DataFrameElem[Row, ArrayDF[Row]]
    with ConcreteElem[ArrayDFData[Row], ArrayDF[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[Row]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }

    override def convertDataFrame(x: Rep[DataFrame[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ArrayDF: missing fields List(records)")
    override def getDefaultRep = ArrayDF(element[Array[Row]].defaultRepValue)
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[ArrayDF[Row]]
    }
  }

  // state representation type
  type ArrayDFData[Row] = Array[Row]

  // 3) Iso for concrete class
  class ArrayDFIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[ArrayDFData[Row], ArrayDF[Row]] with Def[ArrayDFIso[Row]] {
    override def from(p: Rep[ArrayDF[Row]]) =
      p.records
    override def to(p: Rep[Array[Row]]) = {
      val records = p
      ArrayDF(records)
    }
    lazy val eFrom = element[Array[Row]]
    lazy val eTo = new ArrayDFElem[Row](self)
    lazy val selfType = new ArrayDFIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class ArrayDFIsoElem[Row](eRow: Elem[Row]) extends Elem[ArrayDFIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ArrayDFIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[ArrayDFIso[Row]]
    }
  }
  // 4) constructor and deconstructor
  class ArrayDFCompanionAbs extends CompanionDef[ArrayDFCompanionAbs] with ArrayDFCompanion {
    def selfType = ArrayDFCompanionElem
    override def toString = "ArrayDF"

    @scalan.OverloadId("fromFields")
    def apply[Row](records: Rep[Array[Row]])(implicit eRow: Elem[Row]): Rep[ArrayDF[Row]] =
      mkArrayDF(records)

    def unapply[Row](p: Rep[DataFrame[Row]]) = unmkArrayDF(p)
  }
  lazy val ArrayDFRep: Rep[ArrayDFCompanionAbs] = new ArrayDFCompanionAbs
  lazy val ArrayDF: ArrayDFCompanionAbs = proxyArrayDFCompanion(ArrayDFRep)
  implicit def proxyArrayDFCompanion(p: Rep[ArrayDFCompanionAbs]): ArrayDFCompanionAbs = {
    proxyOps[ArrayDFCompanionAbs](p)
  }

  implicit case object ArrayDFCompanionElem extends CompanionElem[ArrayDFCompanionAbs] {
    lazy val tag = weakTypeTag[ArrayDFCompanionAbs]
    protected def getDefaultRep = ArrayDF
  }

  implicit def proxyArrayDF[Row](p: Rep[ArrayDF[Row]]): ArrayDF[Row] =
    proxyOps[ArrayDF[Row]](p)

  implicit class ExtendedArrayDF[Row](p: Rep[ArrayDF[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[ArrayDFData[Row]] = isoArrayDF(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoArrayDF[Row](implicit eRow: Elem[Row]): Iso[ArrayDFData[Row], ArrayDF[Row]] =
    reifyObject(new ArrayDFIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkArrayDF[Row](records: Rep[Array[Row]])(implicit eRow: Elem[Row]): Rep[ArrayDF[Row]]
  def unmkArrayDF[Row](p: Rep[DataFrame[Row]]): Option[(Rep[Array[Row]])]

  abstract class AbsPairDF[L, R]
      (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends PairDF[L, R](left, right) with Def[PairDF[L, R]] {
    lazy val selfType = element[PairDF[L, R]]
  }
  // elem for concrete class
  class PairDFElem[L, R](val iso: Iso[PairDFData[L, R], PairDF[L, R]])(implicit val eL: Elem[L], val eR: Elem[R])
    extends DataFrameElem[(L, R), PairDF[L, R]]
    with ConcreteElem[PairDFData[L, R], PairDF[L, R]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(pairElement(element[L],element[R])))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("L" -> Left(eL), "R" -> Left(eR))
    }

    override def convertDataFrame(x: Rep[DataFrame[(L, R)]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PairDF: missing fields List(left, right)")
    override def getDefaultRep = PairDF(element[DataFrame[L]].defaultRepValue, element[DataFrame[R]].defaultRepValue)
    override lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[PairDF[L, R]]
    }
  }

  // state representation type
  type PairDFData[L, R] = (DataFrame[L], DataFrame[R])

  // 3) Iso for concrete class
  class PairDFIso[L, R](implicit eL: Elem[L], eR: Elem[R])
    extends EntityIso[PairDFData[L, R], PairDF[L, R]] with Def[PairDFIso[L, R]] {
    override def from(p: Rep[PairDF[L, R]]) =
      (p.left, p.right)
    override def to(p: Rep[(DataFrame[L], DataFrame[R])]) = {
      val Pair(left, right) = p
      PairDF(left, right)
    }
    lazy val eFrom = pairElement(element[DataFrame[L]], element[DataFrame[R]])
    lazy val eTo = new PairDFElem[L, R](self)
    lazy val selfType = new PairDFIsoElem[L, R](eL, eR)
    def productArity = 2
    def productElement(n: Int) = (eL, eR).productElement(n)
  }
  case class PairDFIsoElem[L, R](eL: Elem[L], eR: Elem[R]) extends Elem[PairDFIso[L, R]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PairDFIso[L, R]()(eL, eR))
    lazy val tag = {
      implicit val tagL = eL.tag
      implicit val tagR = eR.tag
      weakTypeTag[PairDFIso[L, R]]
    }
  }
  // 4) constructor and deconstructor
  class PairDFCompanionAbs extends CompanionDef[PairDFCompanionAbs] with PairDFCompanion {
    def selfType = PairDFCompanionElem
    override def toString = "PairDF"
    @scalan.OverloadId("fromData")
    def apply[L, R](p: Rep[PairDFData[L, R]])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
      isoPairDF(eL, eR).to(p)
    @scalan.OverloadId("fromFields")
    def apply[L, R](left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
      mkPairDF(left, right)

    def unapply[L, R](p: Rep[DataFrame[(L, R)]]) = unmkPairDF(p)
  }
  lazy val PairDFRep: Rep[PairDFCompanionAbs] = new PairDFCompanionAbs
  lazy val PairDF: PairDFCompanionAbs = proxyPairDFCompanion(PairDFRep)
  implicit def proxyPairDFCompanion(p: Rep[PairDFCompanionAbs]): PairDFCompanionAbs = {
    proxyOps[PairDFCompanionAbs](p)
  }

  implicit case object PairDFCompanionElem extends CompanionElem[PairDFCompanionAbs] {
    lazy val tag = weakTypeTag[PairDFCompanionAbs]
    protected def getDefaultRep = PairDF
  }

  implicit def proxyPairDF[L, R](p: Rep[PairDF[L, R]]): PairDF[L, R] =
    proxyOps[PairDF[L, R]](p)

  implicit class ExtendedPairDF[L, R](p: Rep[PairDF[L, R]])(implicit eL: Elem[L], eR: Elem[R]) {
    def toData: Rep[PairDFData[L, R]] = isoPairDF(eL, eR).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPairDF[L, R](implicit eL: Elem[L], eR: Elem[R]): Iso[PairDFData[L, R], PairDF[L, R]] =
    reifyObject(new PairDFIso[L, R]()(eL, eR))

  // 6) smart constructor and deconstructor
  def mkPairDF[L, R](left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]]
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]): Option[(Rep[DataFrame[L]], Rep[DataFrame[R]])]

  abstract class AbsShardedDF[Row]
      (nShards: Rep[Int], distrib: Rep[Row => Int], shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row])
    extends ShardedDF[Row](nShards, distrib, shards) with Def[ShardedDF[Row]] {
    lazy val selfType = element[ShardedDF[Row]]
  }
  // elem for concrete class
  class ShardedDFElem[Row](val iso: Iso[ShardedDFData[Row], ShardedDF[Row]])(implicit override val eRow: Elem[Row])
    extends DataFrameElem[Row, ShardedDF[Row]]
    with ConcreteElem[ShardedDFData[Row], ShardedDF[Row]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[Row]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("Row" -> Left(eRow))
    }

    override def convertDataFrame(x: Rep[DataFrame[Row]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ShardedDF: missing fields List(nShards, distrib, shards)")
    override def getDefaultRep = ShardedDF(0, constFun[Row, Int](0), element[Array[DataFrame[Row]]].defaultRepValue)
    override lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[ShardedDF[Row]]
    }
  }

  // state representation type
  type ShardedDFData[Row] = (Int, (Row => Int, Array[DataFrame[Row]]))

  // 3) Iso for concrete class
  class ShardedDFIso[Row](implicit eRow: Elem[Row])
    extends EntityIso[ShardedDFData[Row], ShardedDF[Row]] with Def[ShardedDFIso[Row]] {
    override def from(p: Rep[ShardedDF[Row]]) =
      (p.nShards, p.distrib, p.shards)
    override def to(p: Rep[(Int, (Row => Int, Array[DataFrame[Row]]))]) = {
      val Pair(nShards, Pair(distrib, shards)) = p
      ShardedDF(nShards, distrib, shards)
    }
    lazy val eFrom = pairElement(element[Int], pairElement(element[Row => Int], element[Array[DataFrame[Row]]]))
    lazy val eTo = new ShardedDFElem[Row](self)
    lazy val selfType = new ShardedDFIsoElem[Row](eRow)
    def productArity = 1
    def productElement(n: Int) = eRow
  }
  case class ShardedDFIsoElem[Row](eRow: Elem[Row]) extends Elem[ShardedDFIso[Row]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ShardedDFIso[Row]()(eRow))
    lazy val tag = {
      implicit val tagRow = eRow.tag
      weakTypeTag[ShardedDFIso[Row]]
    }
  }
  // 4) constructor and deconstructor
  class ShardedDFCompanionAbs extends CompanionDef[ShardedDFCompanionAbs] with ShardedDFCompanion {
    def selfType = ShardedDFCompanionElem
    override def toString = "ShardedDF"
    @scalan.OverloadId("fromData")
    def apply[Row](p: Rep[ShardedDFData[Row]])(implicit eRow: Elem[Row]): Rep[ShardedDF[Row]] =
      isoShardedDF(eRow).to(p)
    @scalan.OverloadId("fromFields")
    def apply[Row](nShards: Rep[Int], distrib: Rep[Row => Int], shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row]): Rep[ShardedDF[Row]] =
      mkShardedDF(nShards, distrib, shards)

    def unapply[Row](p: Rep[DataFrame[Row]]) = unmkShardedDF(p)
  }
  lazy val ShardedDFRep: Rep[ShardedDFCompanionAbs] = new ShardedDFCompanionAbs
  lazy val ShardedDF: ShardedDFCompanionAbs = proxyShardedDFCompanion(ShardedDFRep)
  implicit def proxyShardedDFCompanion(p: Rep[ShardedDFCompanionAbs]): ShardedDFCompanionAbs = {
    proxyOps[ShardedDFCompanionAbs](p)
  }

  implicit case object ShardedDFCompanionElem extends CompanionElem[ShardedDFCompanionAbs] {
    lazy val tag = weakTypeTag[ShardedDFCompanionAbs]
    protected def getDefaultRep = ShardedDF
  }

  implicit def proxyShardedDF[Row](p: Rep[ShardedDF[Row]]): ShardedDF[Row] =
    proxyOps[ShardedDF[Row]](p)

  implicit class ExtendedShardedDF[Row](p: Rep[ShardedDF[Row]])(implicit eRow: Elem[Row]) {
    def toData: Rep[ShardedDFData[Row]] = isoShardedDF(eRow).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoShardedDF[Row](implicit eRow: Elem[Row]): Iso[ShardedDFData[Row], ShardedDF[Row]] =
    reifyObject(new ShardedDFIso[Row]()(eRow))

  // 6) smart constructor and deconstructor
  def mkShardedDF[Row](nShards: Rep[Int], distrib: Rep[Row => Int], shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row]): Rep[ShardedDF[Row]]
  def unmkShardedDF[Row](p: Rep[DataFrame[Row]]): Option[(Rep[Int], Rep[Row => Int], Rep[Array[DataFrame[Row]]])]

  registerModule(DataFrames_Module)
}

// Std -----------------------------------
trait DataFramesStd extends ScalanStd with DataFramesDsl {
  self: DataFramesDslStd =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class StdFlintFileDF[Row]
      (override val fileName: Rep[String])(implicit eRow: Elem[Row])
    extends AbsFlintFileDF[Row](fileName) {
  }

  def mkFlintFileDF[Row]
    (fileName: Rep[String])(implicit eRow: Elem[Row]): Rep[FlintFileDF[Row]] =
    new StdFlintFileDF[Row](fileName)
  def unmkFlintFileDF[Row](p: Rep[DataFrame[Row]]) = p match {
    case p: FlintFileDF[Row] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class StdInputDF[Row]
      (override val dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends AbsInputDF[Row](dataSourceId) {
  }

  def mkInputDF[Row]
    (dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[InputDF[Row]] =
    new StdInputDF[Row](dataSourceId)
  def unmkInputDF[Row](p: Rep[DataFrame[Row]]) = p match {
    case p: InputDF[Row] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class StdPhysicalRddDF[Row]
      (override val dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends AbsPhysicalRddDF[Row](dataSourceId) {
  }

  def mkPhysicalRddDF[Row]
    (dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[PhysicalRddDF[Row]] =
    new StdPhysicalRddDF[Row](dataSourceId)
  def unmkPhysicalRddDF[Row](p: Rep[DataFrame[Row]]) = p match {
    case p: PhysicalRddDF[Row] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class StdArrayDF[Row]
      (override val records: Rep[Array[Row]])(implicit eRow: Elem[Row])
    extends AbsArrayDF[Row](records) {
  }

  def mkArrayDF[Row]
    (records: Rep[Array[Row]])(implicit eRow: Elem[Row]): Rep[ArrayDF[Row]] =
    new StdArrayDF[Row](records)
  def unmkArrayDF[Row](p: Rep[DataFrame[Row]]) = p match {
    case p: ArrayDF[Row] @unchecked =>
      Some((p.records))
    case _ => None
  }

  case class StdPairDF[L, R]
      (override val left: DF[L], override val right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends AbsPairDF[L, R](left, right) {
  }

  def mkPairDF[L, R]
    (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
    new StdPairDF[L, R](left, right)
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]) = p match {
    case p: PairDF[L, R] @unchecked =>
      Some((p.left, p.right))
    case _ => None
  }

  case class StdShardedDF[Row]
      (override val nShards: Rep[Int], override val distrib: Rep[Row => Int], override val shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row])
    extends AbsShardedDF[Row](nShards, distrib, shards) {
  }

  def mkShardedDF[Row]
    (nShards: Rep[Int], distrib: Rep[Row => Int], shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row]): Rep[ShardedDF[Row]] =
    new StdShardedDF[Row](nShards, distrib, shards)
  def unmkShardedDF[Row](p: Rep[DataFrame[Row]]) = p match {
    case p: ShardedDF[Row] @unchecked =>
      Some((p.nShards, p.distrib, p.shards))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends ScalanExp with DataFramesDsl {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[Row]
      (override val fileName: Rep[String])(implicit eRow: Elem[Row])
    extends AbsFlintFileDF[Row](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[Row]
    (fileName: Rep[String])(implicit eRow: Elem[Row]): Rep[FlintFileDF[Row]] =
    new ExpFlintFileDF[Row](fileName)
  def unmkFlintFileDF[Row](p: Rep[DataFrame[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[Row] @unchecked =>
      Some((p.asRep[FlintFileDF[Row]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[Row]
      (override val dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends AbsInputDF[Row](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[Row]
    (dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[InputDF[Row]] =
    new ExpInputDF[Row](dataSourceId)
  def unmkInputDF[Row](p: Rep[DataFrame[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[Row] @unchecked =>
      Some((p.asRep[InputDF[Row]].dataSourceId))
    case _ =>
      None
  }

  case class ExpPhysicalRddDF[Row]
      (override val dataSourceId: Rep[String])(implicit eRow: Elem[Row])
    extends AbsPhysicalRddDF[Row](dataSourceId)

  object PhysicalRddDFMethods {
  }

  object PhysicalRddDFCompanionMethods {
  }

  def mkPhysicalRddDF[Row]
    (dataSourceId: Rep[String])(implicit eRow: Elem[Row]): Rep[PhysicalRddDF[Row]] =
    new ExpPhysicalRddDF[Row](dataSourceId)
  def unmkPhysicalRddDF[Row](p: Rep[DataFrame[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PhysicalRddDFElem[Row] @unchecked =>
      Some((p.asRep[PhysicalRddDF[Row]].dataSourceId))
    case _ =>
      None
  }

  case class ExpArrayDF[Row]
      (override val records: Rep[Array[Row]])(implicit eRow: Elem[Row])
    extends AbsArrayDF[Row](records)

  object ArrayDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[ArrayDF[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ArrayDF[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ArrayDF[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ArrayDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[Rep[Array[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(arr, _*), _) if receiver.elem == ArrayDFCompanionElem && method.getName == "create" =>
          Some(arr).asInstanceOf[Option[Rep[Array[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Array[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkArrayDF[Row]
    (records: Rep[Array[Row]])(implicit eRow: Elem[Row]): Rep[ArrayDF[Row]] =
    new ExpArrayDF[Row](records)
  def unmkArrayDF[Row](p: Rep[DataFrame[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ArrayDFElem[Row] @unchecked =>
      Some((p.asRep[ArrayDF[Row]].records))
    case _ =>
      None
  }

  case class ExpPairDF[L, R]
      (override val left: DF[L], override val right: DF[R])(implicit eL: Elem[L], eR: Elem[R])
    extends AbsPairDF[L, R](left, right)

  object PairDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[PairDF[L, R]] forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[PairDFElem[_, _]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[PairDF[L, R]] forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[PairDF[L, R]] forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object PairDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[(DF[L], DF[R]) forSome {type L; type R}] = d match {
        case MethodCall(receiver, method, Seq(left, right, _*), _) if receiver.elem == PairDFCompanionElem && method.getName == "create" =>
          Some((left, right)).asInstanceOf[Option[(DF[L], DF[R]) forSome {type L; type R}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(DF[L], DF[R]) forSome {type L; type R}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkPairDF[L, R]
    (left: DF[L], right: DF[R])(implicit eL: Elem[L], eR: Elem[R]): Rep[PairDF[L, R]] =
    new ExpPairDF[L, R](left, right)
  def unmkPairDF[L, R](p: Rep[DataFrame[(L, R)]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PairDFElem[L, R] @unchecked =>
      Some((p.asRep[PairDF[L, R]].left, p.asRep[PairDF[L, R]].right))
    case _ =>
      None
  }

  case class ExpShardedDF[Row]
      (override val nShards: Rep[Int], override val distrib: Rep[Row => Int], override val shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row])
    extends AbsShardedDF[Row](nShards, distrib, shards)

  object ShardedDFMethods {
    object toArray {
      def unapply(d: Def[_]): Option[Rep[ShardedDF[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ShardedDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ShardedDF[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ShardedDF[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ShardedDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[(Rep[Int], Rep[Int => DataFrame[Row]], Rep[Row => Int]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(nShards, createShard, distrib, _*), _) if receiver.elem == ShardedDFCompanionElem && method.getName == "create" =>
          Some((nShards, createShard, distrib)).asInstanceOf[Option[(Rep[Int], Rep[Int => DataFrame[Row]], Rep[Row => Int]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[Int], Rep[Int => DataFrame[Row]], Rep[Row => Int]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkShardedDF[Row]
    (nShards: Rep[Int], distrib: Rep[Row => Int], shards: Rep[Array[DataFrame[Row]]])(implicit eRow: Elem[Row]): Rep[ShardedDF[Row]] =
    new ExpShardedDF[Row](nShards, distrib, shards)
  def unmkShardedDF[Row](p: Rep[DataFrame[Row]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ShardedDFElem[Row] @unchecked =>
      Some((p.asRep[ShardedDF[Row]].nShards, p.asRep[ShardedDF[Row]].distrib, p.asRep[ShardedDF[Row]].shards))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[Row => Boolean]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[Row => Boolean]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[Row => Boolean]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[Row => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type Row; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[Row => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type Row; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[Row => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type Row; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[((S, Row)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type Row; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[((S, Row)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type Row; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[((S, Row)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type Row; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[Row => P]) forSome {type Row; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[Row => P]) forSome {type Row; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[Row => P]) forSome {type Row; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[Struct], Rep[Int]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[Struct], Rep[Int]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[Struct], Rep[Int]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[((Row, Row)) => Int], Rep[Int]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], DF[I], Rep[Row => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type Row; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[Row]], Rep[Row]) forSome {type Row}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[Row]], Rep[Row]) forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[Row]], Rep[Row]) forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep

    object toArray {
      def unapply(d: Def[_]): Option[Rep[DataFrame[Row]] forSome {type Row}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[Row]] forSome {type Row}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[Row]] forSome {type Row}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAO1YTWwbRRQeO7Edx2kS0lIJUEJiDG35sUMB9RChKtgxpHKTyBsQClWr8e442TI7u8yOg82hcIoQ3BAXDhwqQAipQkI9VuoFkBBCPaAKIcGFA6dSVOXQigOImfHuetdeu3FoAwf2sNqdffN+vve9tzNz4TqI2RQ8YqsQQ5I1EINZRT7P2yyjLBCms8ZJU6thVEDV1M25mZ+38otRMLYG4hvQLth4DSSbDwt1y3tWmFYCSUhUZDOT2gzMlKSFnGpijFSmmySnG0aNwQpGuZJus7kSGKyYWuM1cA5ESmBcNYlKEUNKHkPbRrYzPoSER7r3npTvjWWrZYPkRBQ5XxSrFOqMu89tjDfly8hSGsQkDYOBUce1ZUu4xWUSumGZlLkmElzdhqm5r4ME8gEwUToLN2GOm1jPKYzqZJ3PTFlQfRWuoyUuIsQHucM2wtXVhiXfB7iIzTQO0KJhYalxoG4BAHgKjkovsi2Ash5AWQFQRkFUh1h/A4qPK9SsN0DzigwAULe4isdvo8LVgBaIlnnnlPrKLSVlRMXkunAlIR2Kc0UPdqGDzAUH8pvye/b28+ePRcHwGhjW7fmKzShUmT/nDlwpSIjJpM8egpCu83Slu6VLWpnnMm2cSKqmYUHCNTlYjvBEYV3VmRAWYyNOerpgn2AWckUjdSvixTvdJV5JnDzEeOXafU88/NvCy1EQDZpIcpUKZz51lTKQLEAGi5TLOPrFfYyBgbL5uoRZ3JJ1d3i0iHXCdjandU/08NrD79C137WvZ8GpqIe64+TOEs1VxOwff0hdPXI8CobWZF0UMVxf48DbCxgZyzRvErYGhsxNRJtfEpsQi6fQxCc0VIU1zJx0+HEc4DgyMN21gi0kQJ6TxRJxAUg1+b5kEpQprmRuKt++f0HQmYKR5pdmSf+lH/vzp9Eqk0xnYKiqY1mhLZBRC5GHulHBQitUN3jv2UTPfHnpxRuXl2KSDRNOUC9BXEPNTuDE1IpPmI2m0wzEWwLt2RxuuqyYBronva2fPv8uk3mL1IPNZrlylhf3nJw30yOFbtP7Ymvr3hsfn9kva3WoojMDWpnZPirVLay7WIkgyPrRvNP8JQ2fDH5MyXop8hwWil1KQ9zv977JW5pn4IBvZt4fQNo3zWdsMuJyTQoxMIh4Obp+DIoK2EG1dnqc9sg22Z1sHJ2D5dIBfP345SiInQCxKq8quwRiFbNGNBd2/pdkqM6ec8ciQdg5zJA3FQ9meU2DVszhXSkVCca1Rx2tA3/Qhv+IxnUqZo2qaFHrrF5xOxyu9jF5z/bDs8QisWqsX46NO7P2kl9+T9O+Gfn/891HvvetbDRsnddgWdP6zfrBwNy9zH2n1/8GAxKrYo1ZKN651CcoUk2q2SH/aGckNk8pbOzQ4j/tBdJW373AmbWnvcDn6d1hQo8Vh4VWaxZGT1/64/Tbb71gyeVLxwI5qD5SauEhXssdMfXg2JV+dfVFwUGMqsxVFm0nt2PM52OHghjV1zd6aAj3b+ckPRr8GF+BOu2Xo2PNSbuiaBSVehA0BKBOBeVeCjrxCQR5W3r7+RAuUG538b/XB4myAbv3wUM8iFk+ukhYLyYmNL77p3olRAsFU93LuVgj6tXFD/aPTZ75RW524pppQF2yZIqvRSnfkMi15pRT123RRmZ6eRW3e4XWpcXvMCO9qn4XP4CkzALqe2Ew4c3by59A0Nt+fwO+lMVDkRrgu8o7kpQO2ALpaRsOQ9czG4Ju4CRm9zgIFpdbUo7ocCtg5hw2kGxVLIOdECg3F15WirMT5iCeu/Xh0qNXLv4qS2tY7KlNgoh38Og/Pwjiuq9lvmBjn8+cJWKn7TlxpJsTTBMnkMjg5po7/u0TnyUf+LzykfxpD4lDSqRi2zuSCT+4PQmtOXnyeLjHySMXyiwYFmuIh6e+evb7N7/79BN5FvM3TW6bkn0WAAA="
}
}

