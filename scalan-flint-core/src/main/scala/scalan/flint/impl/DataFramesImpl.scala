package scalan.flint

import scalan._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends DataFrames with Scalan {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[T](p: Rep[DataFrame[T]]): DataFrame[T] = {
    proxyOps[DataFrame[T]](p)(scala.reflect.classTag[DataFrame[T]])
  }

  // familyElem
  class DataFrameElem[T, To <: DataFrame[T]](implicit _eT: Elem[T])
    extends EntityElem[To] {
    def eT = _eT
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[DataFrame[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[T]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[T]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[T]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e")
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[T](implicit eT: Elem[T]): Elem[DataFrame[T]] =
    cachedElem[DataFrameElem[T, DataFrame[T]]](eT)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanion(p: Rep[DataFrameCompanion]): DataFrameCompanion =
    proxyOps[DataFrameCompanion](p)

  abstract class AbsFlintFileDF[T]
      (fileName: Rep[String])(implicit eT: Elem[T])
    extends FlintFileDF[T](fileName) with Def[FlintFileDF[T]] {
    lazy val selfType = element[FlintFileDF[T]]
  }
  // elem for concrete class
  class FlintFileDFElem[T](val iso: Iso[FlintFileDFData[T], FlintFileDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, FlintFileDF[T]]
    with ConcreteElem[FlintFileDFData[T], FlintFileDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDF[T]]
    }
  }

  // state representation type
  type FlintFileDFData[T] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[T](implicit eT: Elem[T])
    extends Iso[FlintFileDFData[T], FlintFileDF[T]] {
    override def from(p: Rep[FlintFileDF[T]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eTo = new FlintFileDFElem[T](this)
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    def apply[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
      mkFlintFileDF(fileName)
  }
  object FlintFileDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDF: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[T](p: Rep[FlintFileDF[T]]): FlintFileDF[T] =
    proxyOps[FlintFileDF[T]](p)

  implicit class ExtendedFlintFileDF[T](p: Rep[FlintFileDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlintFileDFData[T]] = isoFlintFileDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[T](implicit eT: Elem[T]): Iso[FlintFileDFData[T], FlintFileDF[T]] =
    cachedIso[FlintFileDFIso[T]](eT)

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]]
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsInputDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends InputDF[T](dataSourceId) with Def[InputDF[T]] {
    lazy val selfType = element[InputDF[T]]
  }
  // elem for concrete class
  class InputDFElem[T](val iso: Iso[InputDFData[T], InputDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, InputDF[T]]
    with ConcreteElem[InputDFData[T], InputDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDF[T]]
    }
  }

  // state representation type
  type InputDFData[T] = String

  // 3) Iso for concrete class
  class InputDFIso[T](implicit eT: Elem[T])
    extends Iso[InputDFData[T], InputDF[T]] {
    override def from(p: Rep[InputDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eTo = new InputDFElem[T](this)
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
      mkInputDF(dataSourceId)
  }
  object InputDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkInputDF(p)
  }
  lazy val InputDF: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[T](p: Rep[InputDF[T]]): InputDF[T] =
    proxyOps[InputDF[T]](p)

  implicit class ExtendedInputDF[T](p: Rep[InputDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[InputDFData[T]] = isoInputDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[T](implicit eT: Elem[T]): Iso[InputDFData[T], InputDF[T]] =
    cachedIso[InputDFIso[T]](eT)

  // 6) smart constructor and deconstructor
  def mkInputDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]]
  def unmkInputDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  registerModule(DataFrames_Module)
}

// Seq -----------------------------------
trait DataFramesSeq extends DataFramesDsl with ScalanSeq {
  self: DataFramesDslSeq =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class SeqFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName) {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new SeqFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: FlintFileDF[T] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class SeqInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId) {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new SeqInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: InputDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends DataFramesDsl with ScalanExp {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new ExpFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[T] @unchecked =>
      Some((p.asRep[FlintFileDF[T]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new ExpInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[T] @unchecked =>
      Some((p.asRep[InputDF[T]].dataSourceId))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAL1WzW8bRRR/XsdxbIc0RBWilSpSY77BTpFQDzlUqWOjIJNE2RQhUyGN12N3y+zMZncc2Rz6B8ANcUXQI1JvnBBShYSQEAdOCJA4cyqtUAXtCcSb8X4mdhMq0T2MdmffvI/f7/fe7o3bkPM9eNa3CCO86lBJqqa+X/NlxWxwacvRm6I7YHSd9p4UX3927vPTXxpwog2zV4i/7rM2FMY3jaEb3Zt0rwUFwi3qS+H5Es62dISaJRijlrQFr9mOM5Ckw2itZftytQUzHdEd7cE1yLRg0RLc8qikZp0R36d+sD9HVUZ29FzQz6MtN47Ba6qKWqKKXY/YEtPHGItj+x3qmiMu+MiRsBCktuWqtNAmbzuu8GQYIo/urohu+DjDCW7AUusq2Sc1DNGvmdKzeR9PllxivUf6dBNNlPkMJuxT1tsdufo524KiT/cQoA3HZXpn6AIAMvCqTqIa41ON8KkqfCom9WzC7PeJerntieEIxlcmCzB00cXLR7gIPdAG71Y+uGy9c98sOYY6PFSp5HWFs+joqSlq0FQgjt/tfOTfff36eQOKbSja/lrHlx6xZJLyAK0S4VxInXMEIPH6yFZ5Gls6yhraHJBEwRKOSzh6CqCcR56YbdlSGau9+YCdKdDnpUtD08zQzUT1Lk+pV+umThjbvnXqlWd+b7xtgJEOUUCXJgrfC51KKKwTSZoe2gT+1XpCQmZXg6yWwjDcXGgym8vjnIjX/AMyjrB77tad7rcrcNmIEA8SPB7J6CLn//JT6ccXLhgw19Yt0WSk30bQ/QajzpZXF1y2YU7sU2/8Jr9PmLqbSHq+S3tkwGRARRLDLGIoYXlq87pUAbyqGyUTAlAaa31TcFppblfumd9/fENJ2YP58ZtxN/9jn//714We1CqXMNezmW7OEOIsDoIIkaenycCl257t4NjZp69989WlP25u5rQSloKi3iJsQMdDIKgprk+FNcplCbOxwUE2i+OUTeHQx8t37Xevfyg1b5lhes5sda5iY6/qc2cfQGE47/5qrxh/nvr5UwMKyFTHlg5xKyvH7NL/sfMgrfOFejDrtfTOpV+WdIc0kbf15uR2iJYyQn0yYV5PZl2OR9zpRIQzmVBU2gi5orth6Bkl9CNb8nCK5UhRZ6YrCuF4Yqd1kt2+cNOA3BuQ62Hr+C3IdcSAd0Oc8Sso6VBeDPcyaZwRV4JzI8JVX8sQ1ztp7JQy6ZoewcA6hDocQH2+ix5NMfAsutE93JxqeX6y25f0Wv0vkspvcHcgjyWnxcD0UUkpmVo5YX/xSGoTNM1OhCSLA+EhiJ+MTwr6NGwRdkuR+wnopT6UD1utWkVsExgW47Jk8DXg1Z6SbZC1h8Em96UZjC2E6tr9TzZf/OGL3/SgL6oBiJ8aHv0UJgd8Gr3H4vD4n5fIGVWgxqLO918jClnrdwsAAA=="
}
}

