package scalan.flint

import scalan._
import scala.reflect.runtime.universe._
import scalan.common.Default

package impl {
// Abs -----------------------------------
trait DataFramesAbs extends Scalan with DataFrames {
  self: DataFramesDsl =>

  // single proxy for each type family
  implicit def proxyDataFrame[T](p: Rep[DataFrame[T]]): DataFrame[T] = {
    proxyOps[DataFrame[T]](p)(scala.reflect.classTag[DataFrame[T]])
  }

  // familyElem
  class DataFrameElem[T, To <: DataFrame[T]](implicit _eT: Elem[T])
    extends EntityElem[To] {
    def eT = _eT
    lazy val parent: Option[Elem[_]] = None
    lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }
    override def isEntityType = true
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[DataFrame[T]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[DataFrame[T]] => convertDataFrame(x) }
      tryConvert(element[DataFrame[T]], this, x, conv)
    }

    def convertDataFrame(x: Rep[DataFrame[T]]): Rep[To] = {
      x.selfType1 match {
        case _: DataFrameElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have DataFrameElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def dataFrameElement[T](implicit eT: Elem[T]): Elem[DataFrame[T]] =
    cachedElem[DataFrameElem[T, DataFrame[T]]](eT)

  implicit case object DataFrameCompanionElem extends CompanionElem[DataFrameCompanionAbs] {
    lazy val tag = weakTypeTag[DataFrameCompanionAbs]
    protected def getDefaultRep = DataFrame
  }

  abstract class DataFrameCompanionAbs extends CompanionDef[DataFrameCompanionAbs] with DataFrameCompanion {
    def selfType = DataFrameCompanionElem
    override def toString = "DataFrame"
  }
  def DataFrame: Rep[DataFrameCompanionAbs]
  implicit def proxyDataFrameCompanionAbs(p: Rep[DataFrameCompanionAbs]): DataFrameCompanionAbs =
    proxyOps[DataFrameCompanionAbs](p)

  abstract class AbsFlintFileDF[T]
      (fileName: Rep[String])(implicit eT: Elem[T])
    extends FlintFileDF[T](fileName) with Def[FlintFileDF[T]] {
    lazy val selfType = element[FlintFileDF[T]]
  }
  // elem for concrete class
  class FlintFileDFElem[T](val iso: Iso[FlintFileDFData[T], FlintFileDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, FlintFileDF[T]]
    with ConcreteElem[FlintFileDFData[T], FlintFileDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to FlintFileDF: missing fields List(fileName)")
    override def getDefaultRep = FlintFileDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDF[T]]
    }
  }

  // state representation type
  type FlintFileDFData[T] = String

  // 3) Iso for concrete class
  class FlintFileDFIso[T](implicit eT: Elem[T])
    extends EntityIso[FlintFileDFData[T], FlintFileDF[T]] with Def[FlintFileDFIso[T]] {
    override def from(p: Rep[FlintFileDF[T]]) =
      p.fileName
    override def to(p: Rep[String]) = {
      val fileName = p
      FlintFileDF(fileName)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new FlintFileDFElem[T](self)
    lazy val selfType = new FlintFileDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class FlintFileDFIsoElem[T](eT: Elem[T]) extends Elem[FlintFileDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new FlintFileDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[FlintFileDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class FlintFileDFCompanionAbs extends CompanionDef[FlintFileDFCompanionAbs] with FlintFileDFCompanion {
    def selfType = FlintFileDFCompanionElem
    override def toString = "FlintFileDF"

    def apply[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
      mkFlintFileDF(fileName)
  }
  object FlintFileDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkFlintFileDF(p)
  }
  lazy val FlintFileDF: Rep[FlintFileDFCompanionAbs] = new FlintFileDFCompanionAbs
  implicit def proxyFlintFileDFCompanion(p: Rep[FlintFileDFCompanionAbs]): FlintFileDFCompanionAbs = {
    proxyOps[FlintFileDFCompanionAbs](p)
  }

  implicit case object FlintFileDFCompanionElem extends CompanionElem[FlintFileDFCompanionAbs] {
    lazy val tag = weakTypeTag[FlintFileDFCompanionAbs]
    protected def getDefaultRep = FlintFileDF
  }

  implicit def proxyFlintFileDF[T](p: Rep[FlintFileDF[T]]): FlintFileDF[T] =
    proxyOps[FlintFileDF[T]](p)

  implicit class ExtendedFlintFileDF[T](p: Rep[FlintFileDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[FlintFileDFData[T]] = isoFlintFileDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoFlintFileDF[T](implicit eT: Elem[T]): Iso[FlintFileDFData[T], FlintFileDF[T]] =
    reifyObject(new FlintFileDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkFlintFileDF[T](fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]]
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsInputDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends InputDF[T](dataSourceId) with Def[InputDF[T]] {
    lazy val selfType = element[InputDF[T]]
  }
  // elem for concrete class
  class InputDFElem[T](val iso: Iso[InputDFData[T], InputDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, InputDF[T]]
    with ConcreteElem[InputDFData[T], InputDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to InputDF: missing fields List(dataSourceId)")
    override def getDefaultRep = InputDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDF[T]]
    }
  }

  // state representation type
  type InputDFData[T] = String

  // 3) Iso for concrete class
  class InputDFIso[T](implicit eT: Elem[T])
    extends EntityIso[InputDFData[T], InputDF[T]] with Def[InputDFIso[T]] {
    override def from(p: Rep[InputDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      InputDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new InputDFElem[T](self)
    lazy val selfType = new InputDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class InputDFIsoElem[T](eT: Elem[T]) extends Elem[InputDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new InputDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[InputDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class InputDFCompanionAbs extends CompanionDef[InputDFCompanionAbs] with InputDFCompanion {
    def selfType = InputDFCompanionElem
    override def toString = "InputDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
      mkInputDF(dataSourceId)
  }
  object InputDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkInputDF(p)
  }
  lazy val InputDF: Rep[InputDFCompanionAbs] = new InputDFCompanionAbs
  implicit def proxyInputDFCompanion(p: Rep[InputDFCompanionAbs]): InputDFCompanionAbs = {
    proxyOps[InputDFCompanionAbs](p)
  }

  implicit case object InputDFCompanionElem extends CompanionElem[InputDFCompanionAbs] {
    lazy val tag = weakTypeTag[InputDFCompanionAbs]
    protected def getDefaultRep = InputDF
  }

  implicit def proxyInputDF[T](p: Rep[InputDF[T]]): InputDF[T] =
    proxyOps[InputDF[T]](p)

  implicit class ExtendedInputDF[T](p: Rep[InputDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[InputDFData[T]] = isoInputDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoInputDF[T](implicit eT: Elem[T]): Iso[InputDFData[T], InputDF[T]] =
    reifyObject(new InputDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkInputDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]]
  def unmkInputDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsPhysicalRddDF[T]
      (dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends PhysicalRddDF[T](dataSourceId) with Def[PhysicalRddDF[T]] {
    lazy val selfType = element[PhysicalRddDF[T]]
  }
  // elem for concrete class
  class PhysicalRddDFElem[T](val iso: Iso[PhysicalRddDFData[T], PhysicalRddDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, PhysicalRddDF[T]]
    with ConcreteElem[PhysicalRddDFData[T], PhysicalRddDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to PhysicalRddDF: missing fields List(dataSourceId)")
    override def getDefaultRep = PhysicalRddDF("")
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDF[T]]
    }
  }

  // state representation type
  type PhysicalRddDFData[T] = String

  // 3) Iso for concrete class
  class PhysicalRddDFIso[T](implicit eT: Elem[T])
    extends EntityIso[PhysicalRddDFData[T], PhysicalRddDF[T]] with Def[PhysicalRddDFIso[T]] {
    override def from(p: Rep[PhysicalRddDF[T]]) =
      p.dataSourceId
    override def to(p: Rep[String]) = {
      val dataSourceId = p
      PhysicalRddDF(dataSourceId)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new PhysicalRddDFElem[T](self)
    lazy val selfType = new PhysicalRddDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class PhysicalRddDFIsoElem[T](eT: Elem[T]) extends Elem[PhysicalRddDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new PhysicalRddDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[PhysicalRddDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class PhysicalRddDFCompanionAbs extends CompanionDef[PhysicalRddDFCompanionAbs] with PhysicalRddDFCompanion {
    def selfType = PhysicalRddDFCompanionElem
    override def toString = "PhysicalRddDF"

    def apply[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
      mkPhysicalRddDF(dataSourceId)
  }
  object PhysicalRddDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkPhysicalRddDF(p)
  }
  lazy val PhysicalRddDF: Rep[PhysicalRddDFCompanionAbs] = new PhysicalRddDFCompanionAbs
  implicit def proxyPhysicalRddDFCompanion(p: Rep[PhysicalRddDFCompanionAbs]): PhysicalRddDFCompanionAbs = {
    proxyOps[PhysicalRddDFCompanionAbs](p)
  }

  implicit case object PhysicalRddDFCompanionElem extends CompanionElem[PhysicalRddDFCompanionAbs] {
    lazy val tag = weakTypeTag[PhysicalRddDFCompanionAbs]
    protected def getDefaultRep = PhysicalRddDF
  }

  implicit def proxyPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]]): PhysicalRddDF[T] =
    proxyOps[PhysicalRddDF[T]](p)

  implicit class ExtendedPhysicalRddDF[T](p: Rep[PhysicalRddDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[PhysicalRddDFData[T]] = isoPhysicalRddDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoPhysicalRddDF[T](implicit eT: Elem[T]): Iso[PhysicalRddDFData[T], PhysicalRddDF[T]] =
    reifyObject(new PhysicalRddDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkPhysicalRddDF[T](dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]]
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]): Option[(Rep[String])]

  abstract class AbsArrayDF[T]
      (records: Rep[Array[T]])(implicit eT: Elem[T])
    extends ArrayDF[T](records) with Def[ArrayDF[T]] {
    lazy val selfType = element[ArrayDF[T]]
  }
  // elem for concrete class
  class ArrayDFElem[T](val iso: Iso[ArrayDFData[T], ArrayDF[T]])(implicit eT: Elem[T])
    extends DataFrameElem[T, ArrayDF[T]]
    with ConcreteElem[ArrayDFData[T], ArrayDF[T]] {
    override lazy val parent: Option[Elem[_]] = Some(dataFrameElement(element[T]))
    override lazy val tyArgSubst: Map[String, TypeDesc] = {
      Map("T" -> Left(eT))
    }

    override def convertDataFrame(x: Rep[DataFrame[T]]) = // Converter is not generated by meta
!!!("Cannot convert from DataFrame to ArrayDF: missing fields List(records)")
    override def getDefaultRep = ArrayDF(element[Array[T]].defaultRepValue)
    override lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ArrayDF[T]]
    }
  }

  // state representation type
  type ArrayDFData[T] = Array[T]

  // 3) Iso for concrete class
  class ArrayDFIso[T](implicit eT: Elem[T])
    extends EntityIso[ArrayDFData[T], ArrayDF[T]] with Def[ArrayDFIso[T]] {
    override def from(p: Rep[ArrayDF[T]]) =
      p.records
    override def to(p: Rep[Array[T]]) = {
      val records = p
      ArrayDF(records)
    }
    lazy val eFrom = element[Array[T]]
    lazy val eTo = new ArrayDFElem[T](self)
    lazy val selfType = new ArrayDFIsoElem[T](eT)
    def productArity = 1
    def productElement(n: Int) = eT
  }
  case class ArrayDFIsoElem[T](eT: Elem[T]) extends Elem[ArrayDFIso[T]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new ArrayDFIso[T]()(eT))
    lazy val tag = {
      implicit val tagT = eT.tag
      weakTypeTag[ArrayDFIso[T]]
    }
  }
  // 4) constructor and deconstructor
  class ArrayDFCompanionAbs extends CompanionDef[ArrayDFCompanionAbs] with ArrayDFCompanion {
    def selfType = ArrayDFCompanionElem
    override def toString = "ArrayDF"

    def apply[T](records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
      mkArrayDF(records)
  }
  object ArrayDFMatcher {
    def unapply[T](p: Rep[DataFrame[T]]) = unmkArrayDF(p)
  }
  lazy val ArrayDF: Rep[ArrayDFCompanionAbs] = new ArrayDFCompanionAbs
  implicit def proxyArrayDFCompanion(p: Rep[ArrayDFCompanionAbs]): ArrayDFCompanionAbs = {
    proxyOps[ArrayDFCompanionAbs](p)
  }

  implicit case object ArrayDFCompanionElem extends CompanionElem[ArrayDFCompanionAbs] {
    lazy val tag = weakTypeTag[ArrayDFCompanionAbs]
    protected def getDefaultRep = ArrayDF
  }

  implicit def proxyArrayDF[T](p: Rep[ArrayDF[T]]): ArrayDF[T] =
    proxyOps[ArrayDF[T]](p)

  implicit class ExtendedArrayDF[T](p: Rep[ArrayDF[T]])(implicit eT: Elem[T]) {
    def toData: Rep[ArrayDFData[T]] = isoArrayDF(eT).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoArrayDF[T](implicit eT: Elem[T]): Iso[ArrayDFData[T], ArrayDF[T]] =
    reifyObject(new ArrayDFIso[T]()(eT))

  // 6) smart constructor and deconstructor
  def mkArrayDF[T](records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]]
  def unmkArrayDF[T](p: Rep[DataFrame[T]]): Option[(Rep[Array[T]])]

  registerModule(DataFrames_Module)
}

// Seq -----------------------------------
trait DataFramesSeq extends ScalanSeq with DataFramesDsl {
  self: DataFramesDslSeq =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class SeqFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName) {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new SeqFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: FlintFileDF[T] @unchecked =>
      Some((p.fileName))
    case _ => None
  }

  case class SeqInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId) {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new SeqInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: InputDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId) {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new SeqPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: PhysicalRddDF[T] @unchecked =>
      Some((p.dataSourceId))
    case _ => None
  }

  case class SeqArrayDF[T]
      (override val records: Rep[Array[T]])(implicit eT: Elem[T])
    extends AbsArrayDF[T](records) {
  }

  def mkArrayDF[T]
    (records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
    new SeqArrayDF[T](records)
  def unmkArrayDF[T](p: Rep[DataFrame[T]]) = p match {
    case p: ArrayDF[T] @unchecked =>
      Some((p.records))
    case _ => None
  }
}

// Exp -----------------------------------
trait DataFramesExp extends ScalanExp with DataFramesDsl {
  self: DataFramesDslExp =>
  lazy val DataFrame: Rep[DataFrameCompanionAbs] = new DataFrameCompanionAbs {
  }

  case class ExpFlintFileDF[T]
      (override val fileName: Rep[String])(implicit eT: Elem[T])
    extends AbsFlintFileDF[T](fileName)

  object FlintFileDFMethods {
  }

  object FlintFileDFCompanionMethods {
  }

  def mkFlintFileDF[T]
    (fileName: Rep[String])(implicit eT: Elem[T]): Rep[FlintFileDF[T]] =
    new ExpFlintFileDF[T](fileName)
  def unmkFlintFileDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: FlintFileDFElem[T] @unchecked =>
      Some((p.asRep[FlintFileDF[T]].fileName))
    case _ =>
      None
  }

  case class ExpInputDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsInputDF[T](dataSourceId)

  object InputDFMethods {
  }

  object InputDFCompanionMethods {
  }

  def mkInputDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[InputDF[T]] =
    new ExpInputDF[T](dataSourceId)
  def unmkInputDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: InputDFElem[T] @unchecked =>
      Some((p.asRep[InputDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpPhysicalRddDF[T]
      (override val dataSourceId: Rep[String])(implicit eT: Elem[T])
    extends AbsPhysicalRddDF[T](dataSourceId)

  object PhysicalRddDFMethods {
  }

  object PhysicalRddDFCompanionMethods {
  }

  def mkPhysicalRddDF[T]
    (dataSourceId: Rep[String])(implicit eT: Elem[T]): Rep[PhysicalRddDF[T]] =
    new ExpPhysicalRddDF[T](dataSourceId)
  def unmkPhysicalRddDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: PhysicalRddDFElem[T] @unchecked =>
      Some((p.asRep[PhysicalRddDF[T]].dataSourceId))
    case _ =>
      None
  }

  case class ExpArrayDF[T]
      (override val records: Rep[Array[T]])(implicit eT: Elem[T])
    extends AbsArrayDF[T](records)

  object ArrayDFMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object joinTables {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], DF[T], DF[I], Rep[T => K], Rep[I => K]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(outer, inner, outKey, inKey, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "joinTables" =>
          Some((receiver, outer, inner, outKey, inKey)).asInstanceOf[Option[(Rep[ArrayDF[T]], DF[T], DF[I], Rep[T => K], Rep[I => K]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], DF[T], DF[I], Rep[T => K], Rep[I => K]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[ArrayDF[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[ArrayDF[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object saveFile {
      def unapply(d: Def[_]): Option[(Rep[ArrayDF[T]], String) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(fileName, _*), _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "saveFile" =>
          Some((receiver, fileName)).asInstanceOf[Option[(Rep[ArrayDF[T]], String) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[ArrayDF[T]], String) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object toArray {
      def unapply(d: Def[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[ArrayDFElem[_]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[ArrayDF[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[ArrayDF[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object ArrayDFCompanionMethods {
    object create {
      def unapply(d: Def[_]): Option[Rep[Array[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(arr, _*), _) if receiver.elem == ArrayDFCompanionElem && method.getName == "create" =>
          Some(arr).asInstanceOf[Option[Rep[Array[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Array[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  def mkArrayDF[T]
    (records: Rep[Array[T]])(implicit eT: Elem[T]): Rep[ArrayDF[T]] =
    new ExpArrayDF[T](records)
  def unmkArrayDF[T](p: Rep[DataFrame[T]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: ArrayDFElem[T] @unchecked =>
      Some((p.asRep[ArrayDF[T]].records))
    case _ =>
      None
  }

  object DataFrameMethods {
    object filter {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(p, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "filter" =>
          Some((receiver, p)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => Boolean]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object mapReduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = d match {
        case MethodCall(receiver, method, Seq(map, reduce, estimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "mapReduce" =>
          Some((receiver, map, reduce, estimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => (K, V)], Rep[((V, V)) => V], Rep[Int]) forSome {type T; type K; type V}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object reduce {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = d match {
        case MethodCall(receiver, method, Seq(accumulate, combine, initState, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "reduce" =>
          Some((receiver, accumulate, combine, initState)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((S, T)) => S], Rep[((S, S)) => S], Rep[S]) forSome {type T; type S}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object project {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = d match {
        case MethodCall(receiver, method, Seq(projection, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "project" =>
          Some((receiver, projection)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T => P]) forSome {type T; type P}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sort {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sort" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object sortBy {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, sizeEstimation, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "sortBy" =>
          Some((receiver, compare, sizeEstimation)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[Struct], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object top {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(compare, n, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "top" =>
          Some((receiver, compare, n)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[((T, T)) => Int], Rep[Int]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object join {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "join" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object semijoin {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = d match {
        case MethodCall(receiver, method, Seq(innerRdd, outerKey, innerKey, estimation, kind, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "semijoin" =>
          Some((receiver, innerRdd, outerKey, innerKey, estimation, kind)).asInstanceOf[Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], DF[I], Rep[T => K], Rep[I => K], Rep[Int], Rep[Int]) forSome {type T; type I; type K}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object replicate {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "replicate" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    object result {
      def unapply(d: Def[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = d match {
        case MethodCall(receiver, method, Seq(defaultValue, _*), _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "result" =>
          Some((receiver, defaultValue)).asInstanceOf[Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[(Rep[DataFrame[T]], Rep[T]) forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }

    // WARNING: Cannot generate matcher for method `saveFile`: Method's return type Unit is not a Rep

    object toArray {
      def unapply(d: Def[_]): Option[Rep[DataFrame[T]] forSome {type T}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[DataFrameElem[_, _]] && method.getName == "toArray" =>
          Some(receiver).asInstanceOf[Option[Rep[DataFrame[T]] forSome {type T}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[DataFrame[T]] forSome {type T}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object DataFrameCompanionMethods {
  }
}

object DataFrames_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAAO1XTWwbRRSeteP4L6QhlAoqVaTG/IPdIqEecqiCY6Mgk0TZgJCpQOPdsbNldnYzM45sDj32ADfEFYlKXJB6QZwQUoWEKiEOnBBC4sypFFU90FMr3ox312vHbmMqfMKH0e7M+/2+996Or95EKcHRs8LCFLOSSyQumfp5TciiWWXSkb23PLtDyTppPeF9/8XZr05+m0DHGmh+D4t1QRso23+odv3o2ST7dZTFzCJCelxIdLquPZQtj1JiScdjZcd1OxI3KSnXHSFX62iu6dm9fXQJGXW0ZHnM4kQSs0KxEEQE+xmiInKi96x+7235Ax+srLIox7LY5diRED74WOrL7xDf7DGP9VyJFoPQtnwVFsikHdf3uAxdpMHcnmeHr3MMwwZarl/EB7gMLtplU3KHtUEz72PrQ9wmmyCixOcgYEFoa7fn6/dkHeUE2QeANlyf6p2ujxACBl7VQZQG+JQifEoKn6JJuIOp8xFWh9vc6/ZQ/2ckEer6YOLlB5gILZAqs4sfX7Deu2Pm3YRS7qpQ0jrDeTD01IRq0FQAjj/ufCpuv3HlXALlGijniLWmkBxbMk55gFYeM+ZJHXMEIOZtYKswiS3tZQ1kRkoia3mujxlYCqBcAJ6oYzlSCau9hYCdCdCnpU9CUaPrG1G+KxPy1XVTwZRu33jylWf+rL6bQIlhF1kwaULh89CoRNl1LHGNg0xgX63HJDJ2NchqyXbDzcUadZg8isZgTd8n4gi75278ZV8/gy4kIsSDAI9GMphIid9+zf/ywvkEyjR0S9QobjcAdFGlxN3iFY/JBsp4B4T3T9IHmKqnsaSnbdLCHSoDKuIYJgFDiVYmNq9PFMCrulGMEIB8v9Y3PUaKte3i3+ZPn11VpczRQv+k3833nHN3f19sSV3lEmVaDtXNGUKchEEQIfL0pDLwyTZ3XBg7B+S1H757+9a1zZSuhOUgqXcw7ZD+EAhyGuSn3CYKBYnmBwKjbOb6IZueSx4t3Hbev/KJ1LwZ3eE5s9W8CI29qvVO34fCcN59ffny47e+/OAx3aeZpiNd7BfPTNGlYVP9h12Ihmt+sRLMfV2GZ4cP87pbasDhem1Ca6j1ZHSmlwIwcDymWYknUIipxZydMsJa00JAIdkNo5hT9f/ATj0cbSEqtFOTCw2QObFTP05vnr+WQKk3UaoFHSXqKNX0OswOIYePoyRd+Xq4ZwxDDhBjGCcRxPq3ggb5jptGeWM4pxnMsUOooxHUF2ywaHodbpEN+3DPquX58WZf0mtpmupKbzC/I6etrKVAa1ZVFY+yEJOv/M/ykVh+ZHuvJxzouR3bnpbrE0O6s2L8cMSz4n0qFtOcWB63xZhPa7CTWuMc947k72FbWXuaupUDrZm1cizK6SiNETs/Fp0kfP0fivAJUA0RMrI9BtHlyOkYTIfuyv8WA7VeH8gEgrlBsjK4ELJSSw2vIAEOzsZ/g83gtgIAXrrz+eaLP3/zh77r5dS9B26bLPpfGL/jjcyYgXv4qxeLGWpD3YZ0vP8AmTTbAnoPAAA="
}
}

